[["index.html", "Préparer ses données avec R et le Tidyverse Chapitre 1 Introduction 1.1 Le parcours de formation 1.2 Le groupe de référents R du pôle ministériel 1.3 Objectifs du module 2", " Préparer ses données avec R et le Tidyverse Maël Theulière &amp; Bruno Terseur 20 March 2025 Chapitre 1 Introduction Crédit photographique Sébastien Colas 1.1 Le parcours de formation Ce dispositif de formation vise à faire monter en compétence les agents du MTECT (Ministère de la Transition écologique et de la Cohésion des territoires) et du MTE (Ministère de la Transition énergétique) dans le domaine de la science de la donnée avec le logiciel R. Il est conçu pour être déployé à l’échelle nationale par le réseau des CVRH (Centre de Valorisation des Ressources Humaines). Le parcours proposé est structuré en modules de 2 jours chacun. Avoir suivi les deux premiers (ou disposer d’un niveau équivalent) est un pré-requis pour suivre les suivants qui sont proposés “à la carte” : Module 1 : Socle - Premier programme en R Module 2 : Socle - Préparation des données Module 3 : Statistiques descriptives Module 4 : Analyse des données multi-dimensionnelles Module 5 : Datavisualisation : Produire des graphiques, des cartes et des tableaux Module 6 : Publications reproductibles avec RMarkdown (à venir) Module 7 : Analyse spatiale Module 8 : Big data et optimisation du code (à venir) Module 9 : Applications interactives avec RShiny (à venir) La mise à disposition des supports de formation se fait par la page d’accueil du parcours de formation. Ces supports sont en licence ouverte. Si vous souhaitez accéder aux sources ou aux données mobilisées pendant les formations, vous pouvez directement les télécharger depuis le Github du pôle ministériel. Un package d’exercices, {savoirfR} rassemble toutes les données et les consignes d’exercices de ce parcours de formation (Modules 1, 2, 5 et 7 seulement pour l’instant). Pour vous tenir au courant de l’offre de formation proposée par le réseau des CVRH, consultez la plateforme formation-ecologie.e2.rie.gouv.fr (un accès intranet MTECT-MTE est nécessaire). Vous pouvez vous abonner au flux RSS pour recevoir les annonces de formation qui vous intéressent. Pour échanger de l’information, discuter autour de R ou encore faire part de difficultés et trouver ensemble les solutions, il existe deux canaux d’entraide : s’inscrire en envoyant un message vide à l’adresse sympa@developpement-durable.gouv.fr ; rejoindre le salon Tchap #utilisateurs_r. 1.2 Le groupe de référents R du pôle ministériel Un groupe pour structurer une offre de formations sur R Un réseau d’entraide 1.3 Objectifs du module 2 Ce module va vous permettre de découvrir un ensemble de méthodes sous R afin de préparer ses données. Préparer ses données sous R, cela veut dire : Savoir les importer dans un environnement R, Mettre ses données dans de bons formats (date, catégorielle) et gérer les données manquantes, Rajouter des variables en fonction de variables existantes, Regrouper des modalités de variables, Joindre des tables entre elles pour obtenir des informations de plusieurs sources, Agréger des données, Bien définir notre table de travail en fonction des indicateurs à analyser et à leurs dimensions d’analyse. … Bref, tout le travail technique préalable entre la collecte de la donnée et sa valorisation proprement dite. On estime qu’un scientifique de la donnée passe en général la moitié de son temps à cela. Sous R, comme souvent, il y a plusieurs façons d’aborder cette question. Ce module de formation privilegie l’exploration des packages du framework tidyverse, qui ont l’avantage d’aborder les différentes phases de préparation des données d’une façon intégrée et cohérente, que ce soit entre elles, ou avec d’autres. "],["le-tidyverse.html", "Chapitre 2 Le tidyverse 2.1 Présentation des packages 2.2 Les spécificités du tidyverse 2.3 D’autres approches possibles", " Chapitre 2 Le tidyverse Le tidyverse est un ensemble de packages proposant une syntaxe cohérente pour remplir l’essentiel des traitements propres à la science de la données, de la lecture des données à la valorisation, en passant par la modélisation. Le manifeste du tidyverse comprend 4 principes clefs pour les packages : Utiliser les structures de données existantes : ne pas créer des objets ad hoc ; Utiliser l’opérateur pipe ; S’intégrer dans l’approche de programmation fonctionnelle de R ; Designé pour les être humains : favoriser la facilité d’usage à la performance machine. 2.1 Présentation des packages 2.1.1 Des packages pour lire des données 2.1.1.1 tidyverse {readr} pour les fichiers plats {readxl} pour les fichiers tableur Excel {haven} pour les données stockées sous des formats propriétaires (SAS, SPSS, …) 2.1.1.2 Hors tidyverse {odbc} / {Rposgresql} pour accéder à des données stockées sous forme de base de données {sf} pour lire des données spatiales {rsdmx} pour lire des données sdmx 2.1.2 Des packages pour manipuler des données 2.1.2.1 tidyverse {dplyr} fonctions correspondant à des “verbes” pour manipuler ses données {tidyr} fonctions pour modifier l’agencement de nos tables entre les lignes et les colonnes 2.1.3 Des packages pour nettoyer des données 2.1.3.1 tidyverse {forcats} permet de manipuler les variables de type catégoriel (ou factor en R) {stringr} permet de manipuler des chaînes de caractères {lubridate} permet de manipuler des dates 2.1.3.2 Hors tidyverse {stringi} permet de manipuler des chaînes de caractères {RcppRoll} qui regroupe des opérations fenêtrées ou glissantes 2.2 Les spécificités du tidyverse Quelques spécificités des fonctions de ce framework : Ces packages sont orientés manipulation de dataframes et non de vecteurs En conséquence, on utilise jamais l’indexation des colonnes de tables (le “$”) pour appeler une variable Chaque fonction ne fait qu’une chose et une seule (c’est une opération élémentaire) L’ensemble des fonctions obéissent à la même logique, ce qui permet de simplifier l’apprentissage L’ensemble de ces opérations élémentaires peuvent s’enchaîner à la manière d’un ETL avec le pipe 2.3 D’autres approches possibles Les fonctions que nous allons voir obéissent à une logique intégrée et simple, qui permet des manipulations complexes, à partir du moment ou l’on est capable d’identifier et de sérier chaque opération élémentaire à réaliser. D’autres packages permettent également de réaliser ce type de manipulations. La différence est qu’ils sont souvent dédiés à une tâche spécifique, ce qui rend la cohérence moins évidente lorsque l’on doit réaliser plusieurs opérations. Un autre package propose toutefois une vision intégrée de la sorte : {data.table}. Plusieurs différences sont à noter : {data.table} est plus rapide sur d’importants volumes de données, le code est très concis. {dplyr} est plus simple à apprendre, le code est plus lisible, il peut s’appliquer à des formats de données multiples, il s’intègre dans un framework global qui va de la lecture des données ({readr}, {readxl}, {haven}…) à leur valorisation ({ggplot2}). "],["bien-commencer.html", "Chapitre 3 Bien commencer 3.1 Créer un projet sous Rstudio pour vous permettre de recenser vos travaux. 3.2 Intégrer vos données 3.3 Créer votre arborescence de projet 3.4 Utilisation du package savoirfR 3.5 Activer les packages nécessaires 3.6 Bien structurer ses projets data", " Chapitre 3 Bien commencer 3.1 Créer un projet sous Rstudio pour vous permettre de recenser vos travaux. Pourquoi travailler avec les projets Rstudio plutôt que les scripts R ? Cela permet la portabilité : le répertoire de travail par défaut d’un projet est le répertoire où est ce projet. Si vous transmettez celui-ci à un collègue, le fait de lancer un programme ne dépend pas de l’arborescence de votre machine. Fini les setwd(\"chemin/qui/marche/uniquement/sur/mon/poste\") ! Toujours sur la portabilité, un projet peut être utilisé avec un outil comme renv qui va vous intégrer en interne au projet l’ensemble des packages nécessaires au projet. Cela permet donc à votre collègue à qui vous passez votre projet de ne pas avoir à les installer et, surtout, si vous mettez à jour votre environnement R, votre projet restera toujours avec les versions des packages avec lesquelles vous avez fait tourner votre projet à l’époque. Cela évite d’avoir à subir les effets d’une mise à jour importante d’un package qui casserait votre code. Pour activer renv sur un projet, il faut l’installer avec install.packages(\"renv\"). Pour intialiser la sauvegarde des packages employés dans le projet, il faut utiliser renv::init() Les packages chargés dans le projet sont enregistrés dans un sous-dossier dédié. En cours de travail sur le projet, la commande renv::snapshot() permet de faire une sauvegarde, la commande renv::restore() permet de charger la dernière sauvegarde. En savoir plus sur renv Cela permet de se forcer à travailler en mode projet : on intègre à un seul endroit tout ce qui est lié à un projet : données brutes, données retravaillées, scripts, illustrations, documentations, publications… et donc y compris les packages avec renv. On peut travailler sur plusieurs projets en même temps, Rstudio ouvre autant de sessions que de projets dans ce cas. Les projets Rstudio intègrent une interface avec les outils de gestion de version Git et SVN. Cela veut dire que vous pouvez versionner votre projet et l’héberger simplement comme répertoire sur des plateformes de gestion de code telle que Github ou Gitlab. Pour créer un projet : Cliquez sur Project en haut à droite puis New Project. Cliquez sur New Directory. 3.2 Intégrer vos données Une bonne pratique est de créer un sous répertoire /data pour stocker les données sur lesquelles vous aurez à travailler. Vous pouvez le faire depuis l’explorateur de fichiers de votre système d’exploitation ou directement à partir de l’explorateur de fichiers de RStudio. Cela marche bien quand on a un seul type de données, mais en général on va avoir à travailler sur des données brutes que l’on va retravailler ensuite et vouloir stocker à part. Si par la suite vous souhaitez avoir des exemples de bonnes pratiques sur comment structurer vos données, vous pouvez vous référer au chapitre data du livre d’Hadley Wickham sur la construction de packages R (tout package R étant aussi un projet !). 3.3 Créer votre arborescence de projet Créer un répertoire /src ou vous mettrez vos scripts R. Créer un répertoire /figures ou vous mettrez vos illustrations issues de R. 3.4 Utilisation du package savoirfR Pour faciliter le déroulé de ce module, l’ensemble des exercices (énoncés, corrigés et données) a été intégré à un package réalisé par le groupe des référents R : {savoirfR} install.packages(&#39;remotes&#39;) remotes::install_github(&quot;MTES-MCT/savoirfR&quot;) Pour l’utiliser, il suffit de créer un nouveau projet dans un nouveau répertoire, en sélectionnant le “Project Type” Exercice Parcours R MTES-MCT. Remplissez et sélectionnez le module suivi. 3.5 Activer les packages nécessaires Commencer par rajouter un script dans le répertoire /src à votre projet qui commencera par : activer l’ensemble des packages nécessaires, charger les données dont vous aurez besoin. library(tidyverse) library(lubridate) library(RcppRoll) library(DT) library(readxl) library(dbplyr) library(RPostgreSQL) library(rsdmx) library(sf) library(stringi) sitadel &lt;- read_excel(&quot;extdata/ROES_201702.xls&quot;, sheet = &quot;AUT_REG&quot;, col_types = c (&quot;text&quot;,&quot;text&quot;,&quot;numeric&quot;,&quot;numeric&quot;,&quot;numeric&quot;,&quot;numeric&quot;)) load(file = &quot;extdata/FormationPreparationDesDonnees.RData&quot;) 3.6 Bien structurer ses projets data Plusieurs documents peuvent vous inspirer sur la structuration de vos projets data par la suite. En voici quelques-uns : https://github.com/pavopax/new-project-template https://nicercode.github.io/blog/2013-04-05-projects/ https://www.inwt-statistics.com/read-blog/a-meaningful-file-structure-for-r-projects.html http://projecttemplate.net/architecture.html À partir du moment où quelques grands principes sont respectés (un répertoire pour les données brutes en lecture seule par exemple), le reste est surtout une question d’attirance plus forte pour l’une ou l’autre solution. L’important est de vous tenir ensuite à conserver toujours la même arborescence dans vos projets afin de vous y retrouver plus simplement. "],["lire-des-données.html", "Chapitre 4 Lire des données 4.1 Lire des fichiers locaux 4.2 Lire des données disponibles sur le web : téléchargement de fichiers 4.3 Lire des données disponibles sur le web via API 4.4 Lire des fichiers avec une dimension spatiale 4.5 Lire des données sous PostgreSQL 4.6 Lire des fichiers au format parquet", " Chapitre 4 Lire des données La première étape d’une chaîne de traitement est d’accéder aux données à traiter. R propose énormément de solutions pour ce faire. Quelle que soit la solution choisie, l’important est de chercher à rendre votre travail reproductible : c’est à dire reproductible dans le temps et reproductible par un collègue, sur une autre machine. L’idéal est indiquer dans le script de préparation des données comment le fichier est arrivé sur votre poste de travail, soit en codant les instructions de téléchargement, soit en ajoutant des commentaires qui vous permettront plus tard de reconstituer le jeu de données que vous utilisez. 4.1 Lire des fichiers locaux 4.1.1 {readxl} : lire des données Excel La fonction read_excel() du package {readxl} permet d’importer les données d’un fichier Excel. On peut spécifier : la feuille, les colonnes, les lignes ou la zone à importer, les lignes à supprimer avant importation, si on souhaite importer la première ligne comme des noms de variables ou non, le format des variables importées, la valeur qui sera interprétée comme étant la valeur manquante. library(readxl) sitadel &lt;- read_excel(&quot;extdata/ROES_201702.xls&quot;, sheet = &quot;AUT_REG&quot;, col_types = c (&quot;text&quot;,&quot;text&quot;,&quot;numeric&quot;,&quot;numeric&quot;,&quot;numeric&quot;,&quot;numeric&quot;)) datatable(sitadel) 4.1.2 read_delim() : lire des fichiers plats La fonction read_delim() de {readr} permet d’importer les données d’un fichier csv. Elle fonctionne de la même façon que read_excel(). On peut spécifier : le caractère délimiteur de colonne, les lignes à supprimer avant importation, si on souhaite importer la première ligne comme des noms de variables ou non, le locale du fichier, la valeur qui sera interprétée comme étant la valeur manquante. read_csv(), read_csv2() et read_tsv() sont des implémentations pré-renseignées de read_delim pour lire des fichiers plats avec séparateurs , ; et tabulaire. 4.2 Lire des données disponibles sur le web : téléchargement de fichiers Parfois, les données que nous exploitons sont disponibles au téléchargement sur le web. 4.2.1 Exemple site de l’INSEE, avec dezippage Il est possible, directement depuis R, de télécharger ces données et, si nécessaire, de les décompresser (dans le répertoire de travail). Exemple sur les données 2019 de l’enquête INSEE sur les hébergements touristiques. # présentation des données sur https://www.insee.fr/fr/statistiques/2021703 url &lt;- &quot;https://www.insee.fr/fr/statistiques/fichier/2021703/base-cc-tourisme-2019-geo2019.zip&quot; download.file(url, destfile = &quot;extdata/base-cc-tourisme-2019-geo2019.zip&quot;) unzip(zipfile = &quot;extdata/base-cc-tourisme-2019-geo2019.zip&quot;, exdir = &quot;extdata&quot;) enq_tourisme &lt;- read_excel(&quot;extdata/base-cc-tourisme-2019-geo2019.xls&quot;, sheet = &quot;COM&quot;, skip = 5) datatable(head(enq_tourisme), options = list(dom = &#39;t&#39;)) 4.2.2 Exemple données sur les logements vacants depuis data.gouv.fr (fichier locvac produit par le CEREMA) # présentation des données sur https://www.data.gouv.fr/fr/datasets/logements-vacants-du-parc-prive-par-anciennete-de-vacance-par-commune-et-par-epci/ url &lt;- &quot;https://www.data.gouv.fr/fr/datasets/r/ed0aa123-6afa-49fe-8e35-797a30a44c43&quot; download.file(url, destfile = &quot;extdata/logements-vacants-du-parc-prive-au-01012021-lovac-.xlsx&quot;, mode = &quot;wb&quot;) lgt_vac_prv &lt;- read_xlsx(&quot;extdata/logements-vacants-du-parc-prive-au-01012021-lovac-.xlsx&quot;, sheet = 1) datatable(head(lgt_vac_prv), options = list(dom = &#39;t&#39;)) 4.3 Lire des données disponibles sur le web via API De plus en plus de mise à disposition de données, se font via des API (Application Programming Interface). Une API correspond à un protocole de communication entre un logiciel fournisseur et un logiciel utilisateur. L’utilisateur doit suivre une série de méthodes définies par le fournisseur. Par rapport au téléchargement de fichier via download.file(), on peut ne récupérer qu’une partie du jeu de données. L’autre avantage est la stabilité des url de téléchargement. En savoir plus sur les API : https://thinkr.fr/les-api-un-enfer/. Connaître les API de l’Etat : https://api.gouv.fr/rechercher-api Plusieurs solutions sont disponibles pour lire des données au travers d’une API dans R : tester l’API sur votre navigateur, et une fois que l’URL de requête est construite, lire le résultat JSON depuis R -&gt; cf exemple URSSAF utiliser en complément le package {httr} qui simplifie le recours aux API dans R -&gt; exemple ODRE utiliser un package wrapper, c’est à dire ‘enrobant’, dédié à une API spécifique, qui simplifie encore plus l’utilisation de l’API et allège l’écriture -&gt; exemple {Didor} du ministère et {rsdmx} de l’INSEE. 4.3.1 Exemple de recours à l’API opendatasoft en utilisant l’API de l’URSSAF ou de l’ODRE Opendatasoft est une solution de plateforme opendata comprenant un catalogue, une visualisation des tables, une valorisation graphiques ou cartographiques du jeu de données diffusé et une API d’accès. Cette solution est utilisée par de nombreux acteurs publics (Urssaf, énergéticiens, collectivités, Groupe La Poste…). Chaque partie (catalogue, métadonnées, enregistrements…) fait l’objet d’une URL d’API distincte, en voici deux exemples. 1er exemple données URSSAF des effectifs salariés et de masse salariale du secteur privé par région : library(jsonlite) url_urssaf_fr &lt;- &quot;https://open.urssaf.fr/api/records/1.0/search/?dataset=effectifs-salaries-et-masse-salariale-du-secteur-prive-par-region-x-na38&amp;q=&amp;rows=10000&amp;facet=grand_secteur_d_activite&amp;facet=secteur_na28i&amp;facet=annee&amp;facet=trimestre&amp;refine.region=Pays+de+la+Loire&quot; reponse_urssaf_fr &lt;- fromJSON(url_urssaf_fr) urssaf_fr &lt;- reponse_urssaf_fr$records$fields datatable(urssaf_fr) La récupération des métadonnées d’un jeu de données se fait avec une autre url, en voici un exemple à partir de la plateforme opendata des réseaux d’énergie (ODRE) # Description du jeu de données dataset_url &lt;- paste0(&quot;https://opendata.reseaux-energies.fr/api/dataset/1.0/prod-region-annuelle-enr&quot;) metadata &lt;- httr::GET(dataset_url) %&gt;% httr::content(&quot;text&quot;) %&gt;% jsonlite::fromJSON(flatten = TRUE) attributs &lt;- metadata$fields datatable(attributs) # Enregistrements data_url &lt;-&quot;https://opendata.reseaux-energies.fr/api/records/1.0/search/?dataset=prod-region-annuelle-enr&amp;q=&amp;rows=50&amp;facet=code_insee_region&amp;refine.code_insee_region=52&quot; prod_annuelle_enr &lt;- jsonlite::fromJSON(data_url)$records$fields 4.3.2 Packages R d’interrogation d’API Pour faciliter l’utilisation de leur API par les utilisateurs de R, certains fournisseurs propose un package R pour se brancher à leur données. Le support vous propose deux exemples (INSEE et CGDD), mais il en existe de nombreux ! Pour trouver des packages R qui facilitent l’utilisation d’API françaises, rdv sur : https://github.com/frrrenchies/frrrenchies#package-packages-package 4.3.2.1 Lire des données du webservice Insee L’Insee met à disposition un webservice d’accès (API) à des données de référence sous le format sdmx. Le package {rsdmx} permet de se connecter directement à ces données. Deux approches sont possibles. La première permet d’accéder à une série particulière. url &lt;- &quot;https://bdm.insee.fr/series/sdmx/data/SERIES_BDM/001564471&quot; datainsee &lt;- as.data.frame(readSDMX(url)) # Encoding(levels(datainsee$TITLE_FR)) &lt;- &quot;UTF-8&quot; Cette approche permet également de télécharger plusieurs séries en une seule requête. Par exemple : nous téléchargeons l’ensemble des données sur les créations et défaillances d’entreprises pour les secteurs de la construction et de l’immobilier sur les Pays de la Loire. url &lt;- &quot;https://bdm.insee.fr/series/sdmx/data/SERIES_BDM/001564471+001564503+001564799+001564823+001582441+001582578+001582597+001582745+001656155+001656161+001655989+001655995&quot; datainsee &lt;- as.data.frame(readSDMX(url)) L’autre approche permet de télécharger un ensemble de données d’une thématique appelé dataflow. Ici, par exemple, on télécharge l’ensemble des données relatives à la construction neuve : url &lt;- &quot;https://bdm.insee.fr/series/sdmx/data/CONSTRUCTION-LOGEMENTS&quot; datainsee &lt;- as.data.frame(readSDMX(url)) 4.3.2.2 Interroger le catalogue DiDo du CGDD et lire les jeux de données grâce à {didor} {didor} est un package R conçu pour explorer et accéder aux données publiées par le SDES au CGDD sur DIDO. Le package {didor} s’installe depuis GitHub : install.packages(&quot;devtools&quot;) devtools::install_github(&quot;mtes-mct/didor&quot;) Voici un exemple d’utilisation pour récupérer les données de consommation de produits pétroliers dans les DROM : # devtools::install_github(&quot;mtes-mct/didor&quot;) library(didor) library(tidyverse) result &lt;- datasets() %&gt;% dido_search(&quot;produit-petrolier&quot;) %&gt;% datafiles() %&gt;% dido_search(&quot;drom&quot;) %&gt;% get_data() knitr::kable(head(result)) Tutoriel complet : https://mtes-mct.github.io/didor/articles/premiers_pas.html 4.4 Lire des fichiers avec une dimension spatiale Le package {sf} (pour simple feature) permet d’importer dans R un fichier ayant une dimension spatiale. Après importation, le fichier est un dataframe avec une variable d’un type nouveau : la géométrie. Deux exemples ici pour lire des données au format shape et geojson. Carte_com_Mayotte &lt;- st_read(dsn = &quot;extdata&quot;, layer = &quot;com_mayotte&quot;) ## Reading layer `com_mayotte&#39; from data source ## `/__w/parcours_r_socle_preparation_des_donnees/parcours_r_socle_preparation_des_donnees/extdata&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 17 features and 11 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 501990.5 ymin: 8562261 xmax: 532559.5 ymax: 8603052 ## Projected CRS: RGM04_UTM_zone_38S plot(Carte_com_Mayotte) communes2017 &lt;- st_read(dsn = &quot;extdata/communes2017.geojson&quot;) ## Reading layer `communes2017&#39; from data source ## `/__w/parcours_r_socle_preparation_des_donnees/parcours_r_socle_preparation_des_donnees/extdata/communes2017.geojson&#39; ## using driver `GeoJSON&#39; ## Simple feature collection with 1281 features and 10 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 280973 ymin: 6582762 xmax: 545050 ymax: 6834665 ## Projected CRS: RGF93 / Lambert-93 plot(communes2017) Le package {sf} contient l’ensemble des fonctions permettant des manipulations sur fichiers géomatiques. On ne traitera pas ici de toutes ces fonctions en détail, se référer pour cela à la documentation du package ou suivre le module 7 du parcours de formation à R du ministère. A noter que {sf} étant complètement compatible avec les packages du tidyverse, la géométrie se conçoit comme une donnée comme une autre, sur laquelle par exemple on peut réaliser des agrégations. On peut également lire des couches directement depuis le web : st_read(&quot;https://france-geojson.gregoiredavid.fr/repo/regions.geojson&quot;) %&gt;% filter(code &gt; &quot;10&quot;) %&gt;% select(code) %&gt;% plot() {sf} propose de lire toutes sortes de données spatiales. sf::st_drivers() ## name ## PCIDSK PCIDSK ## netCDF netCDF ## PDS4 PDS4 ## JP2OpenJPEG JP2OpenJPEG ## PDF PDF ## MBTiles MBTiles ## EEDA EEDA ## ESRI Shapefile ESRI Shapefile ## MapInfo File MapInfo File ## UK .NTF UK .NTF ## OGR_SDTS OGR_SDTS ## S57 S57 ## DGN DGN ## OGR_VRT OGR_VRT ## REC REC ## Memory Memory ## BNA BNA ## CSV CSV ## NAS NAS ## GML GML ## GPX GPX ## LIBKML LIBKML ## KML KML ## GeoJSON GeoJSON ## GeoJSONSeq GeoJSONSeq ## ESRIJSON ESRIJSON ## TopoJSON TopoJSON ## Interlis 1 Interlis 1 ## Interlis 2 Interlis 2 ## OGR_GMT OGR_GMT ## GPKG GPKG ## SQLite SQLite ## OGR_DODS OGR_DODS ## ODBC ODBC ## WAsP WAsP ## PGeo PGeo ## MSSQLSpatial MSSQLSpatial ## OGR_OGDI OGR_OGDI ## PostgreSQL PostgreSQL ## MySQL MySQL ## OpenFileGDB OpenFileGDB ## XPlane XPlane ## DXF DXF ## CAD CAD ## Geoconcept Geoconcept ## GeoRSS GeoRSS ## GPSTrackMaker GPSTrackMaker ## VFK VFK ## PGDUMP PGDUMP ## OSM OSM ## GPSBabel GPSBabel ## SUA SUA ## OpenAir OpenAir ## OGR_PDS OGR_PDS ## WFS WFS ## WFS3 WFS3 ## SOSI SOSI ## HTF HTF ## AeronavFAA AeronavFAA ## Geomedia Geomedia ## EDIGEO EDIGEO ## GFT GFT ## SVG SVG ## CouchDB CouchDB ## Cloudant Cloudant ## Idrisi Idrisi ## ARCGEN ARCGEN ## SEGUKOOA SEGUKOOA ## SEGY SEGY ## XLS XLS ## ODS ODS ## XLSX XLSX ## ElasticSearch ElasticSearch ## Walk Walk ## Carto Carto ## AmigoCloud AmigoCloud ## SXF SXF ## Selafin Selafin ## JML JML ## PLSCENES PLSCENES ## CSW CSW ## VDV VDV ## GMLAS GMLAS ## MVT MVT ## TIGER TIGER ## AVCBin AVCBin ## AVCE00 AVCE00 ## NGW NGW ## HTTP HTTP ## long_name ## PCIDSK PCIDSK Database File ## netCDF Network Common Data Format ## PDS4 NASA Planetary Data System 4 ## JP2OpenJPEG JPEG-2000 driver based on OpenJPEG library ## PDF Geospatial PDF ## MBTiles MBTiles ## EEDA Earth Engine Data API ## ESRI Shapefile ESRI Shapefile ## MapInfo File MapInfo File ## UK .NTF UK .NTF ## OGR_SDTS SDTS ## S57 IHO S-57 (ENC) ## DGN Microstation DGN ## OGR_VRT VRT - Virtual Datasource ## REC EPIInfo .REC ## Memory Memory ## BNA Atlas BNA ## CSV Comma Separated Value (.csv) ## NAS NAS - ALKIS ## GML Geography Markup Language (GML) ## GPX GPX ## LIBKML Keyhole Markup Language (LIBKML) ## KML Keyhole Markup Language (KML) ## GeoJSON GeoJSON ## GeoJSONSeq GeoJSON Sequence ## ESRIJSON ESRIJSON ## TopoJSON TopoJSON ## Interlis 1 Interlis 1 ## Interlis 2 Interlis 2 ## OGR_GMT GMT ASCII Vectors (.gmt) ## GPKG GeoPackage ## SQLite SQLite / Spatialite ## OGR_DODS OGR_DODS ## ODBC ODBC ## WAsP WAsP .map format ## PGeo ESRI Personal GeoDatabase ## MSSQLSpatial Microsoft SQL Server Spatial Database ## OGR_OGDI OGDI Vectors (VPF, VMAP, DCW) ## PostgreSQL PostgreSQL/PostGIS ## MySQL MySQL ## OpenFileGDB ESRI FileGDB ## XPlane X-Plane/Flightgear aeronautical data ## DXF AutoCAD DXF ## CAD AutoCAD Driver ## Geoconcept Geoconcept ## GeoRSS GeoRSS ## GPSTrackMaker GPSTrackMaker ## VFK Czech Cadastral Exchange Data Format ## PGDUMP PostgreSQL SQL dump ## OSM OpenStreetMap XML and PBF ## GPSBabel GPSBabel ## SUA Tim Newport-Peace&#39;s Special Use Airspace Format ## OpenAir OpenAir ## OGR_PDS Planetary Data Systems TABLE ## WFS OGC WFS (Web Feature Service) ## WFS3 OGC WFS 3 client (Web Feature Service) ## SOSI Norwegian SOSI Standard ## HTF Hydrographic Transfer Vector ## AeronavFAA Aeronav FAA ## Geomedia Geomedia .mdb ## EDIGEO French EDIGEO exchange format ## GFT Google Fusion Tables ## SVG Scalable Vector Graphics ## CouchDB CouchDB / GeoCouch ## Cloudant Cloudant / CouchDB ## Idrisi Idrisi Vector (.vct) ## ARCGEN Arc/Info Generate ## SEGUKOOA SEG-P1 / UKOOA P1/90 ## SEGY SEG-Y ## XLS MS Excel format ## ODS Open Document/ LibreOffice / OpenOffice Spreadsheet ## XLSX MS Office Open XML spreadsheet ## ElasticSearch Elastic Search ## Walk Walk ## Carto Carto ## AmigoCloud AmigoCloud ## SXF Storage and eXchange Format ## Selafin Selafin ## JML OpenJUMP JML ## PLSCENES Planet Labs Scenes API ## CSW OGC CSW (Catalog Service for the Web) ## VDV VDV-451/VDV-452/INTREST Data Format ## GMLAS Geography Markup Language (GML) driven by application schemas ## MVT Mapbox Vector Tiles ## TIGER U.S. Census TIGER/Line ## AVCBin Arc/Info Binary Coverage ## AVCE00 Arc/Info E00 (ASCII) Coverage ## NGW NextGIS Web ## HTTP HTTP Fetching Wrapper ## write copy is_raster is_vector vsi ## PCIDSK TRUE FALSE TRUE TRUE TRUE ## netCDF TRUE TRUE TRUE TRUE TRUE ## PDS4 TRUE TRUE TRUE TRUE TRUE ## JP2OpenJPEG FALSE TRUE TRUE TRUE TRUE ## PDF TRUE TRUE TRUE TRUE TRUE ## MBTiles TRUE TRUE TRUE TRUE TRUE ## EEDA FALSE FALSE FALSE TRUE FALSE ## ESRI Shapefile TRUE FALSE FALSE TRUE TRUE ## MapInfo File TRUE FALSE FALSE TRUE TRUE ## UK .NTF FALSE FALSE FALSE TRUE TRUE ## OGR_SDTS FALSE FALSE FALSE TRUE TRUE ## S57 TRUE FALSE FALSE TRUE TRUE ## DGN TRUE FALSE FALSE TRUE TRUE ## OGR_VRT FALSE FALSE FALSE TRUE TRUE ## REC FALSE FALSE FALSE TRUE FALSE ## Memory TRUE FALSE FALSE TRUE FALSE ## BNA TRUE FALSE FALSE TRUE TRUE ## CSV TRUE FALSE FALSE TRUE TRUE ## NAS FALSE FALSE FALSE TRUE TRUE ## GML TRUE FALSE FALSE TRUE TRUE ## GPX TRUE FALSE FALSE TRUE TRUE ## LIBKML TRUE FALSE FALSE TRUE TRUE ## KML TRUE FALSE FALSE TRUE TRUE ## GeoJSON TRUE FALSE FALSE TRUE TRUE ## GeoJSONSeq TRUE FALSE FALSE TRUE TRUE ## ESRIJSON FALSE FALSE FALSE TRUE TRUE ## TopoJSON FALSE FALSE FALSE TRUE TRUE ## Interlis 1 TRUE FALSE FALSE TRUE TRUE ## Interlis 2 TRUE FALSE FALSE TRUE TRUE ## OGR_GMT TRUE FALSE FALSE TRUE TRUE ## GPKG TRUE TRUE TRUE TRUE TRUE ## SQLite TRUE FALSE FALSE TRUE TRUE ## OGR_DODS FALSE FALSE FALSE TRUE FALSE ## ODBC TRUE FALSE FALSE TRUE FALSE ## WAsP TRUE FALSE FALSE TRUE TRUE ## PGeo FALSE FALSE FALSE TRUE FALSE ## MSSQLSpatial TRUE FALSE FALSE TRUE FALSE ## OGR_OGDI FALSE FALSE FALSE TRUE FALSE ## PostgreSQL TRUE FALSE FALSE TRUE FALSE ## MySQL TRUE FALSE FALSE TRUE FALSE ## OpenFileGDB FALSE FALSE FALSE TRUE TRUE ## XPlane FALSE FALSE FALSE TRUE TRUE ## DXF TRUE FALSE FALSE TRUE TRUE ## CAD FALSE FALSE TRUE TRUE TRUE ## Geoconcept TRUE FALSE FALSE TRUE TRUE ## GeoRSS TRUE FALSE FALSE TRUE TRUE ## GPSTrackMaker TRUE FALSE FALSE TRUE TRUE ## VFK FALSE FALSE FALSE TRUE FALSE ## PGDUMP TRUE FALSE FALSE TRUE TRUE ## OSM FALSE FALSE FALSE TRUE TRUE ## GPSBabel TRUE FALSE FALSE TRUE FALSE ## SUA FALSE FALSE FALSE TRUE TRUE ## OpenAir FALSE FALSE FALSE TRUE TRUE ## OGR_PDS FALSE FALSE FALSE TRUE TRUE ## WFS FALSE FALSE FALSE TRUE TRUE ## WFS3 FALSE FALSE FALSE TRUE FALSE ## SOSI FALSE FALSE FALSE TRUE FALSE ## HTF FALSE FALSE FALSE TRUE TRUE ## AeronavFAA FALSE FALSE FALSE TRUE TRUE ## Geomedia FALSE FALSE FALSE TRUE FALSE ## EDIGEO FALSE FALSE FALSE TRUE TRUE ## GFT TRUE FALSE FALSE TRUE FALSE ## SVG FALSE FALSE FALSE TRUE TRUE ## CouchDB TRUE FALSE FALSE TRUE FALSE ## Cloudant TRUE FALSE FALSE TRUE FALSE ## Idrisi FALSE FALSE FALSE TRUE TRUE ## ARCGEN FALSE FALSE FALSE TRUE TRUE ## SEGUKOOA FALSE FALSE FALSE TRUE TRUE ## SEGY FALSE FALSE FALSE TRUE TRUE ## XLS FALSE FALSE FALSE TRUE FALSE ## ODS TRUE FALSE FALSE TRUE TRUE ## XLSX TRUE FALSE FALSE TRUE TRUE ## ElasticSearch TRUE FALSE FALSE TRUE FALSE ## Walk FALSE FALSE FALSE TRUE FALSE ## Carto TRUE FALSE FALSE TRUE FALSE ## AmigoCloud TRUE FALSE FALSE TRUE FALSE ## SXF FALSE FALSE FALSE TRUE TRUE ## Selafin TRUE FALSE FALSE TRUE TRUE ## JML TRUE FALSE FALSE TRUE TRUE ## PLSCENES FALSE FALSE TRUE TRUE FALSE ## CSW FALSE FALSE FALSE TRUE FALSE ## VDV TRUE FALSE FALSE TRUE TRUE ## GMLAS FALSE TRUE FALSE TRUE TRUE ## MVT TRUE FALSE FALSE TRUE TRUE ## TIGER TRUE FALSE FALSE TRUE TRUE ## AVCBin FALSE FALSE FALSE TRUE TRUE ## AVCE00 FALSE FALSE FALSE TRUE TRUE ## NGW TRUE TRUE TRUE TRUE FALSE ## HTTP FALSE FALSE TRUE TRUE FALSE Il comprend notamment un driver pour lire les flux WFS, émis par nos plateforme de données géographiques. Voici un exemple issu de SIGloire : crte &lt;- sf::st_read(dsn = &#39;https://datacarto.sigloire.fr/wfs?REQUEST=getCapabilities&amp;service=WFS&amp;VERSION=2.0.0&#39;, layer = &quot;ms:r_portrait_crte_r52&quot;) crte %&gt;% select(nom_territ) %&gt;% plot On indique au niveau du paramètre dsn l’url du webservice WFS de la plateforme et au niveau du parametre layer le nom de la couche. Pour aller plus loin dans l’exploitation des flux WFS dans R : https://inbo.github.io/tutorials/tutorials/spatial_wfs_services/. 4.5 Lire des données sous PostgreSQL Deux approches possibles pour utiliser des données stockées dans une base de données PostgreSQL. Importer toutes ces données dans l’environnement R se connecter à ces données (sans les charger en mémoire vive) et utiliser un interpréteur permettant de traduire du code R comme une requête SQL. 4.5.1 Lire des données sous PostgreSQL : première approche Le package {DBI} est fréquemment utilisé pour connecter des bases de données à R. On ouvre une connexion en déclarant les informations liées à la base (adresse, identifiants..) et en choisissant le driver de connexion. #Définition du driver drv &lt;- dbDriver(&quot;PostgreSQL&quot;) #Définition de la base de données con &lt;- dbConnect(drv, dbname = &quot;dbname&quot;, host = &quot;ip&quot;, port = numero_du_port, user = &quot;user_name&quot;, password = &quot;pwd&quot;) #Spécification de l&#39;encodage, obligatoire avec Windows postgresqlpqExec(con, &quot;SET client_encoding = &#39;windows-1252&#39;&quot;) #Téléchargement de la table analyse du schéma pesticide parametre &lt;- dbGetQuery(con, &quot;SELECT * FROM pesticides.parametre&quot;) #Téléchargement de données avec dimension spatiale via la fonction st_read du package simple feature station = st_read(con, query = &quot;SELECT * FROM pesticides.station&quot;) station = st_read(dsn = con, layer = c(schema = &#39;pesticides&#39;, table = &#39;station&#39;)) On voit que pour importer notre table analyse, on a simplement lancé une requête SQL. Pour obtenir un résultat qui préserve le caractère spatial de notre jeu de données, il faut changer de fonction de lecture. Un package, encore expérimental, de la DREAL Pays de la Loire, {datalibaba} simplifie l’écriture des instructions de lecture/écriture de données vers ou depuis un SGBD Postgresql/postgis. Il propose de stocker vos identifiants de connexion dans vos variable d’environnement afin d’en préserver la confidentialité et de vous éviter de les réécrire dans chaque script. L’utilisateur n’a plus à se préoccuper du driver de connexion ni de la fonction de lecture. Les instruction précédentes deviennent : remotes::install_gitlab(&#39;dreal-pdl/csd/datalibaba&#39;, host = &quot;gitlab-forge.din.developpement-durable.gouv.fr&quot;) library(datalibaba) parametre &lt;- importer_data(table = &quot;parametre&quot;, schema = &quot;pesticides&quot;) station &lt;- importer_data(table = &quot;station&quot;, schema = &quot;pesticides&quot;) 4.5.2 Lire des données sous PostgreSQL : seconde approche #définition du driver drv &lt;- dbDriver(&quot;PostgreSQL&quot;) #définition de la base de données con &lt;- dbConnect(drv, dbname = &quot;dbname&quot;, host = &quot;ip&quot;, port = numero_du_port, user = &quot;user_name&quot;, password = &quot;pwd&quot;) #spécification de l&#39;encodage, obligatoire avec windows postgresqlpqExec(con, &quot;SET client_encoding = &#39;windows-1252&#39;&quot;) #téléchargement de la table analyse du schéma pesticide analyse_db &lt;- tbl(con, in_schema(&quot;pesticides&quot;, &quot;analyse&quot;)) Ici la table analyse n’est pas chargée dans l’environnement R, R s’est juste connecté à la base de données. On peut réaliser des opérations sur la table analyse avec du code R très simplement. Par exemple pour filtrer sur les analyses relatives au Glyphosate : analyse_db &lt;- filter(analyse_db, code_parametre == 1506) Attention, ce code ne touche pas la base de donnée, il n’est pas exécuté. Pour l’exécuter, il faut par exemple afficher la table. analyse_db Même une fois le code exécuté, cette base n’est pas encore un dataframe. Pour importer la table, on utilise la fonction collect() analyse_db &lt;- collect(analyse_db) Cette approche est à conseiller sur d’importantes bases de données, et sans dimension spatiale, car {dbplyr} ne sait pas encore lire facilement ce type de variable. 4.6 Lire des fichiers au format parquet Apache Parquet est un choix de plus en plus populaire pour le stockage et l’analyse de données. C’est un format binaire optimisé pour réduire la taille des fichiers et offrir une excellente vitesse de lecture, surtout si on souhaite accéder à un jeu de données en ne lisant que quelques colonnes. Egalement, il est lisible dans de nombreux langages et prévoit, un peu comme avec une base de données PostgreSQL, qu’on exprime une requête de lecture pour limiter la montée des données en RAM au minimum nécessaire. Enfin on peut grouper les lignes lors un export parquet et réaliser une partition du fichier, par exemple par département ou par région, dans l’idée que certains utilisateurs n’ont pas besoin d’accéder à tout, pour encore accélérer la lecture. Bref, cela va devenir un must dans la diffusion de données millésimées. La manière la plus courante de lire et d’écrire des données au format Parquet avec R est d’utiliser le package {Arrow}, et ses les fonctions read_parquet() et write_parquet(). Le package parquetize permet de convertir en masse des jeux de données depuis SAS, Stata, sqlite ou JSON vers parquet. library(arrow) datatable(head(iris)) tf &lt;- tempfile() write_parquet(iris, tf) df &lt;- read_parquet(tf, col_select = starts_with(&quot;Se&quot;)) datatable(head(df)) Pour les données spatiales, le format geoparquet est désormais opérationnel (v1 en décembre 2022). Deux packages ont été développés pour l’utilisation de geoparquet avec R : {sfarrow} sur le CRAN et {geoparquet} en phase de développement actif sur github. S’il est très efficace pour l’analyse de données, Parquet est en revanche peu adapté à l’ajout de données en continu ou à la modification fréquente de données existantes. Pour cette utilisation, il faut privilégier un système de gestion de base de données comme par exemple PostgreSQL. Pour en savoir plus sur ce format promis à un bel avenir au ministère : nous vous recommandons la fiche utilitR de l’INSEE dédiée à la question. "],["manipuler-des-données.html", "Chapitre 5 Manipuler des données 5.1 Les principes des fonctions de {dplyr} 5.2 Présentation des données 5.3 Chargement des données 5.4 Les verbes clefs de {dplyr} pour manipuler une table 5.5 La boîte à outils pour créer et modifier des variables avec R 5.6 Agréger des données : summarise() 5.7 Agréger des données par dimension : group_by() 5.8 Le pipe 5.9 La magie des opérations groupées 5.10 Les armes non conventionnelles de la préparation des donnéees", " Chapitre 5 Manipuler des données 5.1 Les principes des fonctions de {dplyr} Le but de {dplyr} est d’identifier et de rassembler dans un seul package les outils de manipulation de données les plus importantes pour l’analyse des données. Ce package rassemble donc des fonctions correspondant à un ensemble d’opérations élémentaires (ou verbes) qui permettent de : Sélectionner un ensemble de variables : select() Sélectionner un ensemble de lignes : filter() Ajouter/modifier/renommer des variables : mutate() ou rename() Produire des statistiques agrégées sur les dimensions d’une table : summarise() Trier une table : arrange() Manipuler plusieurs tables : left_join(), right_join(), full_join(), inner_join()… D’appliquer cela sur des données, quel que soit leur format : dataframes, data.table, couche spatiale, base de données sql, big data… D’appliquer cela en articulation avec group_by() qui change la façon d’interpréter chaque fonction : d’une interprétation globale sur l’ensemble d’une table, on passe alors à une approche groupe par groupe : chaque groupe étant défini par un ensemble des modalités des variables définies dans l’instruction group_by(). 5.2 Présentation des données On va travailler sur ce module principalement à partir des données sitadel en date réelle estimée (permis de construire) et à partir des données de qualité des eaux de surface. 5.3 Chargement des données load(file = &quot;extdata/FormationPreparationDesDonnees.RData&quot;) 5.4 Les verbes clefs de {dplyr} pour manipuler une table 5.4.1 Sélectionner des variables : select() Nous allons ici sélectionner un ensemble de variables de la table des prélèvements. prelevementb &lt;- select( prelevement, date_prelevement, code_prelevement, code_reseau, code_station ) datatable(head(prelevementb)) prelevementb &lt;- select(prelevement, -code_support) names(prelevementb) ## [1] &quot;code_prelevement&quot; &quot;code_intervenant&quot; &quot;code_reseau&quot; &quot;code_station&quot; ## [5] &quot;date_prelevement&quot; select() possède ce qu’on appelle des helpers qui permettent de gagner du temps dans l’écriture de notre sélection. A partir du moment où les conventions de nommage sont correctement effectuées, cela permet de gagner également en reproductibilité d’une année sur l’autre. Exemple : sélectionner toutes les variables qui commencent par “code_” : prelevementb &lt;- select(prelevement, starts_with(&quot;code_&quot;)) Exemple : sélectionner les variables dont les noms sont contenus dans un vecteur de chaînes de caractères : mes_variables &lt;- c(&quot;code_prelevement&quot;, &quot;code_intervenant&quot;, &quot;code_reseau&quot;, &quot;date_prelevement&quot;) prelevementb &lt;- select(prelevement, one_of(mes_variables)) 5.4.2 Trier une table : arrange() prelevementb &lt;- arrange(prelevementb, date_prelevement) 5.4.3 Renommer une variable : rename() prelevementb &lt;- rename(prelevementb, date_p = date_prelevement) On peut aussi directement renommer une variable dans l’opération select() prelevementb &lt;- select(prelevement, date_p = date_prelevement, code_prelevement, code_reseau, code_station) 5.4.4 Filtrer une table : filter() On va ici récupérer les analyses produites par l’ARS ars &lt;- filter(prelevement, code_reseau == &quot;ARS&quot;) L’exemple ci-dessus n’exerce un filtre que sur une condition unique. Pour des conditions cumulatives (toutes les conditions doivent être remplies), le \"&amp;\" ou la \",\" ars &lt;- filter(prelevement, code_reseau == &quot;ARS&quot;, code_intervenant == &quot;44&quot;) Pour des conditions non cumulatives (au moins une des conditions doit être remplie), le “|” ars &lt;- filter(prelevement, code_reseau == &quot;ARS&quot; | code_reseau == &quot;FREDON&quot;) Si une condition non cumulative s’applique sur une même variable, privilégier un test de sélection dans une liste avec le %in% ars &lt;- filter(prelevement, code_reseau %in% c(&quot;ARS&quot;, &quot;FREDON&quot;)) Pour sélectionner des observations qui ne répondent pas à la condition, le ! (la négation d’un test) Toutes les observations ayant été réalisées par un autre réseau que l’ARS : non_ars &lt;- filter(prelevement, code_reseau != &quot;ARS&quot;) Toutes les observations ayant été réalisées par un autre réseau que l’ARS ou FREDON : ni_ars_ni_fredon &lt;- filter(prelevement, !(code_reseau %in% c(&quot;ARS&quot;, &quot;FREDON&quot;))) 5.4.5 Modifier/ajouter une variable : mutate() mutate() est le verbe qui permet la transformation d’une variable existante ou la création d’une nouvelle variable dans le jeu de données. Création de nouvelles variables : prelevementb &lt;- mutate(prelevementb, code_prelevement_caract = as.character(code_prelevement), code_reseau_fact = as.factor(code_reseau) ) Modification de variables existantes : prelevementb &lt;- mutate(prelevementb, code_prelevement = as.character(code_prelevement), code_reseau = as.factor(code_reseau) ) mutate() possède une variante, transmute(), qui fonctionne de la même façon, mais ne conserve que les variables modifiées ou créées par le verbe. 5.4.6 Extraire un vecteur : pull() pull() permet d’extraire sous forme de vecteur une variable d’un dataframe. stations_de_la_table_prelevement &lt;- pull(prelevement, code_station) stations_de_la_table_prelevement &lt;- unique(stations_de_la_table_prelevement) 5.5 La boîte à outils pour créer et modifier des variables avec R 5.5.1 Manipuler des variables numériques Vous pouvez utiliser beaucoup de fonctions pour créer des variables avec mutate() : les opérations arithmétiques : +,-,*,/,^ ; arithmétique modulaire : %/% (division entière) et %% (le reste), où x == y * (x %/% y) + (x %% y) ; logarithmes : log(), log2(), log10() ; navigations entre les lignes : lead() et lag() qui permettent d’avoir accès à la valeur suivante et précédente d’une variable. a &lt;- data.frame(x=sample(1:10)) b &lt;- mutate(a, lagx = lag(x), leadx = lead(x), lag2x = lag(x, n = 2), lead2x = lead(x, n = 2)) datatable(b) opérations cumulatives ou glissantes : R fournit des fonctions pour obtenir des opérations cumulatives les somme, produit, minimum et maximum cumulés, dplyr fournit l’équivalent pour les moyennes : cumsum(), cumprod(), cummin(), cummax(), cummean() Pour appliquer des opérations glissantes, on peut soit créer l’opération avec l’instruction lag(), soit exploiter le package RcppRoll qui permet d’exploiter des fonctions prédéfinies. Exemple de somme glissante sur un pas de 2 observations. a &lt;- data.frame(x = sample(1:10)) b &lt;- mutate(a, cumsumx = cumsum(x), rollsumrx = roll_sumr(x, n = 2)) datatable(b) Attention aux différences entre roll_sum() et roll_sumr(). Contrairement à roll_sum(), la fonction roll_sumr() fait en sorte d’obtenir un vecteur de même dimension que l’entrée : a$x ## [1] 9 2 6 3 8 7 5 1 10 4 rollsumrx &lt;- roll_sumr(a$x, n=2) rollsumx &lt;- roll_sum(a$x, n=2) length(rollsumrx) == length(a$x) ## [1] TRUE length(rollsumx) == length(a$x) ## [1] FALSE Aussi dans le cadre d’opérations sur les dataframes, roll_sum() ne fonctionnera pas. b &lt;- mutate(a, cumsumx = cumsum(x), rollsumx = roll_sum(x, n=2)) Comparaisons logiques : &lt;, &lt;=, &gt;, &gt;=, != Rangs : min_rank() devrait être la plus utile, il existe aussi notamment row_number(), dense_rank(), percent_rank(), cume_dist(), ntile(). coalesce(x, y) : permet de remplacer les valeurs manquantes de x par celle de y variable = ifelse(condition(x), valeursioui, valeursinon) permet d’affecter valeursi ou valeursinon à variable en fonction du fait que x répond à condition. Exemple : création d’une variable résultat pour savoir si les résultats de nos analyses sont bons, ou non. analyseb &lt;- mutate(analyse, resultat_ok = ifelse(code_remarque %in% c(1, 2, 7, 10), yes = TRUE, no = FALSE)) qui peut se résumer, lorsque yes = TRUE et no = FALSE, à : analyseb &lt;- mutate(analyse, resultat_ok = code_remarque %in% c(1, 2, 7, 10)) case_when() permet d’étendre la logique de ifelse() à des cas plus complexes. Les conditions mises dans un case_when() ne sont pas exclusives. De ce fait, il faut pouvoir déterminer l’ordre d’évaluation des conditions qui y sont posées. Cet ordre s’effectue de bas en haut, c’est à dire que la dernière condition évaluée (celle qui primera sur toutes les autres) sera la première à écrire. Exemple: On va ici calculer des seuils fictifs sur les analyses. analyseb &lt;- mutate(analyse, classe_resultat_analyse = case_when( resultat_analyse == 0 ~ &quot;1&quot;, resultat_analyse &lt;= 0.001 ~ &quot;2&quot;, resultat_analyse &lt;= 0.01 ~ &quot;3&quot;, resultat_analyse &lt;= 0.1 ~ &quot;4&quot;, resultat_analyse &gt; 0.1 ~ &quot;5&quot;, TRUE ~ &quot;&quot; )) 5.5.2 Exercice 1 : Les données mensuelles sitadel cf. package d’exercices {savoirfR} À partir du fichier sitadel de février 2017 (ROES_201702.xls), produire un dataframe ‘sit_pdl_ind’ contenant pour la région Pays-de-la-Loire (code région 52), pour chaque mois et pour les logements individuels (définis par la somme des logements individuels purs et individuels groupés : i_AUT = ip_AUT + ig_AUT) : le cumul des autorisations sur 12 mois glissants (i_AUT_cum12), le taux d’évolution du cumul sur 12 mois (i_AUT_cum_evo, en %), la part de ce cumul dans celui de l’ensemble des logements autorisés (log_AUT), en pourcentage. Résultat attendu : solution sans le pipe (apercu des premières lignes) %&gt;% ## # A tibble: 6 × 12 ## date REG log_AUT ip_AUT ig_AUT colres_AUT i_AUT i_AUT_cum12 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 200001 52 1789 1266 245 278 1511 NA ## 2 200002 52 2022 1529 175 318 1704 NA ## 3 200003 52 2270 1466 205 599 1671 NA ## 4 200004 52 2040 1237 162 641 1399 NA ## 5 200005 52 2361 1357 357 647 1714 NA ## 6 200006 52 2504 1436 250 818 1686 NA ## # ℹ 4 more variables: i_AUT_cum12_lag12 &lt;dbl&gt;, i_AUT_cum_evo &lt;dbl&gt;, ## # log_AUT_cum12 &lt;dbl&gt;, part_i_AU &lt;dbl&gt; solution avec le pipe (apercu des premières lignes) %&gt;% ## # A tibble: 6 × 12 ## date REG log_AUT ip_AUT ig_AUT colres_AUT i_AUT i_AUT_cum12 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 200001 52 1789 1266 245 278 1511 NA ## 2 200002 52 2022 1529 175 318 1704 NA ## 3 200003 52 2270 1466 205 599 1671 NA ## 4 200004 52 2040 1237 162 641 1399 NA ## 5 200005 52 2361 1357 357 647 1714 NA ## 6 200006 52 2504 1436 250 818 1686 NA ## # ℹ 4 more variables: i_AUT_cum12_lag12 &lt;dbl&gt;, i_AUT_cum_evo &lt;dbl&gt;, ## # log_AUT_cum12 &lt;dbl&gt;, part_i_AU &lt;dbl&gt; 5.5.3 Manipuler des dates Parmi l’ensemble des manipulations de variables, celle des dates et des heures est toujours une affaire complexe. Le framework tidyverse propose le package {lubridate} qui permet de gérer ces informations de façon cohérente. gestion des dates : dmy(&quot;jeudi 21 novembre 2020&quot;) dmy(&quot;21112020&quot;) ymd(&quot;20201121&quot;) gestion des dates/heures : dmy_hms(&quot;mardi 21 novembre 2020 9:30:00&quot;) now() combien de jours avant Noël ? annee_en_cours &lt;- year(today()) prochain_noel &lt;- paste(&quot;25 décembre&quot;, annee_en_cours) prochain_noel dmy(prochain_noel) - today() le jour de la semaine d’une date : wday(dmy(&quot;19012038&quot;), label = TRUE) Les fonctions make_date() et make_datetime() vous permettent de transformer un ensemble de variables en un format date ou date - heure. C’est par exemple utile lorsque l’on a des variables séparées pour l’année, le mois et le jour. 5.5.3.1 Exercice 2 : les dates Convertir les colonnes de la table exercice au format date (quand c’est pertinent). La table exercice est issue de FormationPreparationDesDonnees.RData. Résultat attendu : ## Rows: 153,497 ## Columns: 22 ## $ code_analyse &lt;int&gt; 5186581, 280131, 1576225, 799894, 472800, 27671… ## $ code_laboratoire &lt;dbl&gt; NA, 292, NA, NA, 292, NA, NA, NA, NA, NA, NA, N… ## $ code_prelevement &lt;int&gt; 37593, 7715, 15517, 9566, 8332, 26792, 35625, 1… ## $ code_parametre &lt;dbl&gt; 1216, 1668, 1185, 1217, 1907, 1945, 1673, 1234,… ## $ code_fraction_analysee &lt;int&gt; 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,… ## $ resultat_analyse &lt;dbl&gt; 0.007, 0.050, 0.040, 0.050, 0.260, 0.020, 0.010… ## $ code_remarque &lt;int&gt; 10, 2, 2, 2, 1, 10, 10, 10, 10, 10, 10, 10, 2, … ## $ limite_detection &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… ## $ limite_quantification &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… ## $ code_intervenant &lt;fct&gt; NA, 104, NA, NA, 104, NA, NA, 53, NA, 44, 49, 4… ## $ code_reseau &lt;fct&gt; OSUR, OSUR, FREDON, OSUR, OSUR, OSUR, OSUR, ARS… ## $ code_station &lt;chr&gt; &quot;04153800&quot;, &quot;04130000&quot;, &quot;04132500&quot;, &quot;04214000&quot;,… ## $ date_prelevement &lt;date&gt; 2014-09-16, 2003-08-05, 2008-09-01, 2007-05-02… ## $ code_support &lt;int&gt; NA, 3, NA, NA, 3, NA, NA, 3, NA, 3, 3, 3, NA, N… ## $ libelle_station &lt;chr&gt; &quot;MOZEE à CHANTONNAY&quot;, &quot;MAYENNE à DAON&quot;, &quot;MAYENN… ## $ date_creation &lt;date&gt; 1900-01-01, 1900-01-01, 1900-01-01, 1900-01-01… ## $ source &lt;chr&gt; &quot;AELB&quot;, &quot;AELB&quot;, &quot;AELB&quot;, &quot;AELB&quot;, &quot;AELB&quot;, &quot;AELB&quot;,… ## $ code_masse_eau &lt;chr&gt; &quot;GR1950&quot;, &quot;GR0460c&quot;, &quot;GR0460c&quot;, &quot;GR0121&quot;, &quot;GR04… ## $ code_entite_hydro &lt;chr&gt; &quot;N3036200&quot;, &quot;M---0090&quot;, &quot;M---0090&quot;, &quot;J78-0300&quot;,… ## $ code_troncon_hydro &lt;chr&gt; &quot;N3036200&quot;, &quot;M3620090&quot;, &quot;M3910090&quot;, &quot;J7800300&quot;,… ## $ code_commune &lt;chr&gt; &quot;85051&quot;, &quot;53089&quot;, &quot;49214&quot;, &quot;44036&quot;, &quot;53017&quot;, &quot;5… ## $ date_formatee &lt;chr&gt; &quot;16/09/2014&quot;, &quot;05/08/2003&quot;, &quot;01/09/2008&quot;, &quot;02/0… 5.5.4 Manipuler des chaînes de caractères Le package {stringr} compile l’ensemble des fonctions de manipulation de chaînes de caractère utiles sur ce type de données. On peut diviser les manipulations de chaînes de caractères en 4 catégories : manipulations des caractères eux-mêmes, gestion des espaces, opérations liées à la langue, manipulations de “pattern”, notamment des expressions régulières. 5.5.4.1 Manipulations sur les caractères Obtenir la longueur d’une chaîne avec str_length() : library(stringr) str_length(&quot;abc&quot;) ## [1] 3 Extraire une chaîne de caractères avec str_sub() str_sub() prend 3 arguments : une chaîne de caractère, une position de début, une position de fin. Les positions peuvent être positives, et dans ce cas, on compte à partir de la gauche, ou négatives, et dans ce cas on compte à partir de la droite. a &lt;- data.frame(x = c(&quot; libeatg&quot;, &quot;delivo y&quot;)) b &lt;- mutate(a, pos3a4 = str_sub(string = x, start = 3, end = 4), pos3a2avtlafin = str_sub(string = x, start = 3, end = -2)) datatable(b) str_sub() peut être utilisé pour remplacer un caractère str_sub(a$x, start = 6, end = 9) &lt;-&quot;rer&quot; a$x ## [1] &quot; liberer&quot; &quot;delivrer&quot; Si on souhaite réaliser ce genre d’opération dans le cadre d’un mutate, il faut utiliser une fonction dite “pipe-operator-friendly”, par exemple stri_sub_replace() du package {stringi} # install.packages(&quot;stringi&quot;) library(stringi) a &lt;- data.frame(x = c(&quot; libeatg&quot;, &quot;delivo y&quot;)) b &lt;- mutate(a, y=stri_sub_replace(str=x, from=6, to=9, value = &quot;rer&quot;)) datatable(b) 5.5.4.2 Gestion des espaces La fonction str_pad() permet de compléter une chaîne de caractère pour qu’elle atteigne une taille fixe. Le cas typique d’usage est la gestion des codes communes Insee. code_insee &lt;- 1001 str_pad(code_insee, 5, pad = &quot;0&quot;) ## [1] &quot;01001&quot; On peut choisir de compléter à gauche, à droite, et on peut choisir le “pad”. Par défaut, celui-ci est l’espace. La fonction inverse de str_pad() est str_trim() qui permet de supprimer les espaces aux extrémités de notre chaîne de caractères. proust &lt;- &quot; Les paradoxes d&#39;aujourd&#39;hui sont les préjugés de demain. &quot; str_trim(proust) ## [1] &quot;Les paradoxes d&#39;aujourd&#39;hui sont les préjugés de demain.&quot; str_trim(proust, side = &quot;left&quot;) ## [1] &quot;Les paradoxes d&#39;aujourd&#39;hui sont les préjugés de demain. &quot; Les expressions régulières permettent la détection de “patterns” sur des chaînes de caractères. Par exemple “^” sert à indiquer que la chaîne de caractère recherchée doit se trouver au début de la chaîne examinée. Au contraire, “$” sert à indiquer que la chaîne de caractère recherchée doit se trouver à la fin. a &lt;- data.frame(txt = c(&quot;vélo&quot;, &quot;train&quot;, &quot;voilier&quot;, &quot;bus&quot;, &quot;avion&quot;, &quot;tram&quot;, &quot;trottinette&quot;)) b &lt;- mutate(a, tr_au_debut = str_detect(string = txt, pattern = &quot;^tr&quot;)) b ## txt tr_au_debut ## 1 vélo FALSE ## 2 train TRUE ## 3 voilier FALSE ## 4 bus FALSE ## 5 avion FALSE ## 6 tram TRUE ## 7 trottinette TRUE filter(b, tr_au_debut) ## txt tr_au_debut ## 1 train TRUE ## 2 tram TRUE ## 3 trottinette TRUE filter(a, str_detect(string = txt, pattern = &quot;n$&quot;)) ## txt ## 1 train ## 2 avion 5.5.4.3 Opérations liées à la langue Ces différentes fonctions ne donneront pas le même résultat en fonction de la langue par défaut utilisée. La gestion des majuscules/minuscules : proust &lt;- &quot;Les paradoxes d&#39;aujourd&#39;hui sont LES préjugés de Demain.&quot; str_to_upper(proust) ## [1] &quot;LES PARADOXES D&#39;AUJOURD&#39;HUI SONT LES PRÉJUGÉS DE DEMAIN.&quot; str_to_lower(proust) ## [1] &quot;les paradoxes d&#39;aujourd&#39;hui sont les préjugés de demain.&quot; str_to_title(proust) ## [1] &quot;Les Paradoxes D&#39;aujourd&#39;hui Sont Les Préjugés De Demain.&quot; La gestion de l’ordre, str_sort() et str_order() : a &lt;- data.frame(x = c(&quot;y&quot;, &quot;i&quot;, &quot;k&quot;)) mutate(a, en_ordre = str_sort(x), selon_position = str_order(x)) ## x en_ordre selon_position ## 1 y i 2 ## 2 i k 3 ## 3 k y 1 Suppression des accents (base::iconv) : proust2 &lt;- &quot;Les paradoxes d&#39;aujourd&#39;hui sont les préjugés de demain ; et ça c&#39;est embêtant&quot; iconv(proust2, to = &quot;ASCII//TRANSLIT&quot;) ## [1] &quot;Les paradoxes d&#39;aujourd&#39;hui sont les prejuges de demain ; et ca c&#39;est embetant&quot; Avec humour, un petit aide-mémoire illustré, très visuel, est proposé par Lise Vaudor ici. 5.5.5 Manipuler des variables factorielles ( = qualitatives ou catégorielles) Les facteurs (ou factors, an anglais) sont un type de vecteur géré nativement par R qui permettent de gérer les variables qualitatives ou catégorielles. Les facteurs sont souvent mis en regard des données labellisées utilisées dans d’autres logiciels statistiques. Les facteurs possèdent un attribut appelé niveaux (levels, en anglais) qui contient l’ensemble des valeurs qui peuvent être prises par les éléments du vecteur. Les fonctions du module {forcats} permettent de modifier les modalités d’une variable factorielle, notamment : changer les modalités des facteurs et/ou leur ordre, regrouper des modalités. On va ici utiliser la fonction fct_infreq(), pour modifier le tri des stations en fonction de leur fréquence d’apparition dans la table “prelevement”. {forcats} permet beaucoup d’autres possibilités de tri : tri manuel des facteurs avec fct_relevel() ; en fonction de la valeur d’une autre variable avec fct_reorder(); en fonction de l’ordre d’apparition des modalités avec fct_inorder(). Consulter la documentation du package {forcats} pour voir toutes les possibilités très riches de ce module. En quoi ces fonctions sont utiles ? Elles permettent notamment : lorsqu’on fait des graphiques, d’afficher les occurences les plus importantes d’abord ; de lier l’ordre d’une variable en fonction d’une autre (par exemple les code Insee des communes en fonction des régions). Exemple : ordonner les modalités d’un facteur pour améliorer l’aspect d’un graphique library(ggplot2) library(forcats) data &lt;- data.frame(num = c(1, 8, 4, 3, 6, 7, 5, 2, 11, 3), cat = c(letters[1:10])) ggplot(data, aes(x = cat, num)) + geom_bar(stat = &quot;identity&quot;) + xlab(label = &quot;Facteur&quot;) + ylab(label = &quot;Valeur&quot;) ggplot(data, aes(x = fct_reorder(cat, -num), num)) + geom_bar (stat = &quot;identity&quot;) + xlab(label = &quot;Facteur ordonné&quot;) + ylab(label = &quot;Valeur&quot;) 5.6 Agréger des données : summarise() La fonction summarise() permet d’agréger des données, en appliquant une fonction sur les variables pour construire une statistique sur les observations de la table. summarise() est une fonction dite de “résumé”. À l’inverse de mutate(), quand une fonction summarise est appelée, elle retourne une seule information. La moyenne, la variance, l’effectif… sont des informations qui condensent la variable étudiée en une seule information. La syntaxe de summarise est classique. Le résultat est un dataframe. summarise(exercice, mesure_moyenne = mean(resultat_analyse, na.rm = TRUE)) On peut calculer plusieurs statistiques sur une agrégation summarise(exercice, mesure_moyenne = mean(resultat_analyse, na.rm = TRUE), mesure_total = sum(resultat_analyse, na.rm = TRUE) ) 5.6.1 Quelques fonctions d’agrégations utiles compter : n() sommer : sum() compter des valeurs non manquantes sum(!is.na()) moyenne : mean(), moyenne pondérée : weighted.mean() écart-type : sd() médiane : median(), quantile : quantile(.,quantile) minimum : min(), maximum : max() position : first(), nth(., position), last() La plupart de ces fonctions d’agrégation sont paramétrables pour indiquer comment traiter les valeurs manquantes (NA) grâce à l’argument na.rm. Si on ne souhaite pas tenir compte des valeurs manquantes pour effectuer notre synthèse, il faut indiquer na.rm = TRUE pour évacuer les valeurs manquantes du calcul, sinon, le résultat apparaîtra comme lui même manquant, car il manque des observations pour pouvoir calculer correctement notre résultat. C’est la connaissance de votre source de données et du travail en court qui déterminera comment vous souhaitez que les valeurs manquantes soit traitées. 5.7 Agréger des données par dimension : group_by() La fonction summarise() est utile, mais la plupart du temps, nous avons besoin non pas d’agréger des données d’une table entière, mais de construire des agrégations sur des sous-ensembles : par année, département… La fonction group_by() va permettre d’éclater notre table en fonction de dimensions de celle-ci. Ainsi, si on veut construire des statistiques agrégées non sur l’ensemble de la table, mais pour chacune des modalités d’une ou de plusieurs variables de la table. Il faut deux étapes : utiliser préalablement la fonction group_by() pour définir la ou les variables sur lesquelles on souhaite agréger les données, utiliser summarise() sur la table en sortie de l’étape précédente. Découper un jeu de données pour réaliser des opérations sur chacun des sous-ensembles afin de les restituer ensuite de façon organisée est appelée stratégie du split – apply – combine schématiquement, c’est cette opération qui est réalisée par dplyr dès qu’un group_by() est introduit sur une table. Exemple pour calculer les statistiques précédentes par année : exercice &lt;- mutate(exercice, annee = year(date_prelevement)) paran &lt;- group_by(exercice, annee) summarise(paran, mesure_moyenne = mean(resultat_analyse, na.rm = TRUE), mesure_total = sum(resultat_analyse, na.rm = TRUE)) ## # A tibble: 26 × 3 ## annee mesure_moyenne mesure_total ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1991 0.0724 1.38 ## 2 1992 0.192 4.42 ## 3 1993 0.137 2.46 ## 4 1994 0.07 2.24 ## 5 1995 0.0687 2.06 ## 6 1996 0.0867 3.99 ## 7 1997 0.0520 2.50 ## 8 1998 0.145 22.8 ## 9 1999 0.0672 44.6 ## 10 2000 0.0586 36.9 ## # ℹ 16 more rows Pour reprendre des traitements “table entière”, il faut mettre fin au group_by() par un ungroup(). La fonction summarise() accepte désormais un argument .groups qui permet d’indiquer directement comment nous souhaitons voir ré-assemblé ou non notre jeu de données. paran &lt;- group_by(exercice, annee, code_reseau) resultat &lt;- summarise(paran, mesure_moyenne = mean(resultat_analyse, na.rm = TRUE), mesure_total = sum(resultat_analyse, na.rm = TRUE)) ## `summarise()` has grouped output by &#39;annee&#39;. You can override using the ## `.groups` argument. Si on omet de lui déclarer comment traiter les groupes en sortie, summarise() nous informe des éventuels groupes résiduels, ici resultat est toujours groupé par annee. Pour remédier à ce message ou changer le comportement de summarise(), .groups peut prendre plusieurs valeurs : \"drop_last\" : va supprimer le dernier niveau de groupement de notre jeu de données. Dans notre exemple le groupe selon code_reseau va disparaître et celui lié à annee va rester. C’est le comportement par défaut. \"drop\" : supprime tous les niveaux de groupement \"keep\" : conserve tous les niveaux de groupement. \"rowwise\" : chaque ligne devient son propre groupe. resultat &lt;- summarise(paran, mesure_moyenne = mean(resultat_analyse, na.rm = TRUE), mesure_total = sum(resultat_analyse, na.rm = TRUE), .groups = &quot;drop&quot;) 5.8 Le pipe Le pipe est la fonction qui va vous permettre d’écrire votre code de façon plus lisible pour vous et les utilisateurs. Comment ? En se rapprochant de l’usage usuel en grammaire. verbe(sujet, complement) devient sujet %&gt;% verbe(complement) Quand on enchaîne plusieurs verbes, l’avantage devient encore plus évident : verbe2(verbe1(sujet, complement1), complement2) devient sujet %&gt;% verbe1(complement1) %&gt;% verbe2(complement2) En reprenant l’exemple précédent, sans passer par les étapes intermédiaires, le code aurait cette tête : summarise ( group_by ( mutate ( exercice, annee = year(date_prelevement) ), annee ), mesure_moyenne = mean(resultat_analyse, na.rm = TRUE), mesure_total = sum(resultat_analyse, na.rm = TRUE) ) ## # A tibble: 26 × 3 ## annee mesure_moyenne mesure_total ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1991 0.0724 1.38 ## 2 1992 0.192 4.42 ## 3 1993 0.137 2.46 ## 4 1994 0.07 2.24 ## 5 1995 0.0687 2.06 ## 6 1996 0.0867 3.99 ## 7 1997 0.0520 2.50 ## 8 1998 0.145 22.8 ## 9 1999 0.0672 44.6 ## 10 2000 0.0586 36.9 ## # ℹ 16 more rows Avec l’utilisation du pipe (raccourci clavier CTrl + Maj + M), il devient : exercice %&gt;% mutate(annee = year(date_prelevement)) %&gt;% group_by(annee) %&gt;% summarise(mesure_moyenne = mean(resultat_analyse, na.rm = TRUE), mesure_total = sum(resultat_analyse, na.rm = TRUE)) ## # A tibble: 26 × 3 ## annee mesure_moyenne mesure_total ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1991 0.0724 1.38 ## 2 1992 0.192 4.42 ## 3 1993 0.137 2.46 ## 4 1994 0.07 2.24 ## 5 1995 0.0687 2.06 ## 6 1996 0.0867 3.99 ## 7 1997 0.0520 2.50 ## 8 1998 0.145 22.8 ## 9 1999 0.0672 44.6 ## 10 2000 0.0586 36.9 ## # ℹ 16 more rows 5.9 La magie des opérations groupées L’opération group_by() que nous venons de voir est très utile pour les agrégations, mais elle peut aussi servir pour créer des variables ou filtrer une table, puisque group_by() permet de traiter notre table en entrée comme autant de tables séparées par les modalités des variables de regroupement. 5.9.1 Exercice 3 A partir des données “sitadel” chargées dans l’exercice 1, effectuer les opérations suivantes en utilisant l’opérateur %&gt;% : effectuer les mêmes calculs que ceux réalisés sur la région 52, mais sur chacune des régions –&gt; à stocker dans ‘sit_ind’ calculer les agrégations par année civile pour chacune des régions, puis leur taux d’évolution d’une année sur l’autre (exemple : (val2015-val2014)/val2014) –&gt; à stocker dans ‘sit_annuel’ Résultat attendu pour sit_ind : ## # A tibble: 5,356 × 12 ## date REG log_AUT ip_AUT ig_AUT colres_AUT i_AUT i_AUT_cum12 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 200001 01 440 194 12 234 206 NA ## 2 200001 02 372 189 14 169 203 NA ## 3 200001 03 172 25 3 144 28 NA ## 4 200001 04 473 325 84 64 409 NA ## 5 200001 11 3029 754 318 1957 1072 NA ## 6 200001 21 547 274 94 179 368 NA ## 7 200001 22 475 328 16 131 344 NA ## 8 200001 23 569 445 35 89 480 NA ## 9 200001 24 1057 714 88 255 802 NA ## 10 200001 25 708 410 206 92 616 NA ## # ℹ 5,346 more rows ## # ℹ 4 more variables: i_AUT_cum12_lag12 &lt;dbl&gt;, i_AUT_cum_evo &lt;dbl&gt;, ## # log_AUT_cum12 &lt;dbl&gt;, part_i_AU &lt;dbl&gt; Résultat attendu pour sit_annuel : ## # A tibble: 468 × 10 ## REG annee log_AUT ip_AUT ig_AUT colres_AUT evol_an_log_AUT evol_an_ip_AUT ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 01 2000 6625 2776 674 3175 NA NA ## 2 02 2000 3956 1805 270 1881 NA NA ## 3 03 2000 1501 363 363 775 NA NA ## 4 04 2000 9749 4580 1246 3923 NA NA ## 5 11 2000 44443 8843 4836 30764 NA NA ## 6 21 2000 5519 3164 890 1465 NA NA ## 7 22 2000 6363 3819 721 1823 NA NA ## 8 23 2000 8803 4712 1256 2835 NA NA ## 9 24 2000 13386 7770 1867 3749 NA NA ## 10 25 2000 8678 5288 1401 1989 NA NA ## # ℹ 458 more rows ## # ℹ 2 more variables: evol_an_ig_AUT &lt;dbl&gt;, evol_an_colres_AUT &lt;dbl&gt; 5.9.2 Exercice 4 Sur les données FormationPreparationDesDonnees.RData, table exercice : 1/ calculer le taux de quantification pour chaque molécule et chacune des années : chaque molécule est identifiée par son code_parametre, le taux de quantification est le nombre de fois qu’une molécule est retrouvée (càd si code_remarque = 1) sur le nombre de fois où elle a été cherchée (càd si code_remarque = 1, 2, 7 ou 10). Pour cela : créer la variable annee créer la variable de comptage des présences pour chaque analyse (1=présent, 0=absent) créer la variable de comptage des recherches pour chaque analyse (1=recherchée, 0=non recherchée) pour chaque combinaison annee x code_parametre, calculer le taux de quantification 2/ trouver pour chaque station, sur l’année 2016, le prélèvement pour lequel la concentration cumulée, toutes substances confondues, est la plus élevée (~ le prélèvement le plus pollué). Pour cela : filtrer les concentrations quantifiées (code_remarque=1) et l’année 2016 sommer les concentrations (resultat_analyse) par combinaison code_station x code_prelevement ne conserver que le prélèvement avec le concentration maximale Résultats attendus : Résultat attendu pour le taux de quantification par molécule et année : ## # A tibble: 6,538 × 3 ## annee code_parametre taux_quantif ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1991 1129 0 ## 2 1991 1130 0 ## 3 1991 1176 0 ## 4 1991 1199 0 ## 5 1991 1212 0 ## 6 1991 1259 0 ## 7 1991 1263 100 ## 8 1991 1267 0 ## 9 1992 1101 0 ## 10 1992 1107 100 ## # ℹ 6,528 more rows Résultat attendu pour prélèvement le plus pollué de chaque station en 2016 : ## # A tibble: 176 × 3 ## libelle_station code_prelevement concentration_cumulee ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 ANGLE GUIGNARD-RETENUE 43003 0.04 ## 2 ANXURE À SAINT-GERMAIN-D&#39;ANXURE 42228 0.02 ## 3 APREMONT-RETENUE 42895 0.035 ## 4 ARAIZE à CHATELAIS 41451 0.006 ## 5 ARON à MOULAY 41359 0.008 ## 6 AUBANCE À LOUERRE 41571 0.08 ## 7 AUBANCE à MURS-ERIGNE 41542 0.317 ## 8 AUBANCE à SAINT-SATURNIN-SUR-LOIRE 41584 0.167 ## 9 AUTHION à LES PONTS-DE-CE 42532 0.27 ## 10 AUTISE À SAINT-HILAIRE-DES-LOGES 41998 0.048 ## # ℹ 166 more rows 5.10 Les armes non conventionnelles de la préparation des donnéees Nous venons de voir les principaux verbes de manipulation d’une table de dplyr. Ces verbes acquièrent encore plus de puissance quand ils sont appelés avec les fonctions across() et/ou where(). 5.10.1 Les select helpers Répéter des opérations de nettoyage ou de typage sur les différentes variables d’un jeu de données peut s’avérer fastidieux lorsque l’on a à écrire les opérations variable par variable. La fonction select() propose cinq manières différentes de désigner les variables à sélectionner. Nous avons vu la première et la plus intuitive, qui est de nommer les variables une à une. On peut également utiliser les : qui permettent de sélectionner une liste de variables consécutives. On peut également désigner les variables à sélectionner en fonction de leur position : select(exercice, code_analyse, code_laboratoire, code_prelevement, code_parametre, code_fraction_analysee, resultat_analyse, code_remarque) %&gt;% names() ## [1] &quot;code_analyse&quot; &quot;code_laboratoire&quot; &quot;code_prelevement&quot; ## [4] &quot;code_parametre&quot; &quot;code_fraction_analysee&quot; &quot;resultat_analyse&quot; ## [7] &quot;code_remarque&quot; select(exercice, code_analyse:code_remarque) %&gt;% names() ## [1] &quot;code_analyse&quot; &quot;code_laboratoire&quot; &quot;code_prelevement&quot; ## [4] &quot;code_parametre&quot; &quot;code_fraction_analysee&quot; &quot;resultat_analyse&quot; ## [7] &quot;code_remarque&quot; select(exercice, -c(code_analyse:code_remarque)) %&gt;% names() ## [1] &quot;limite_detection&quot; &quot;limite_quantification&quot; &quot;code_intervenant&quot; ## [4] &quot;code_reseau&quot; &quot;code_station&quot; &quot;date_prelevement&quot; ## [7] &quot;code_support&quot; &quot;libelle_station&quot; &quot;date_creation&quot; ## [10] &quot;source&quot; &quot;code_masse_eau&quot; &quot;code_entite_hydro&quot; ## [13] &quot;code_troncon_hydro&quot; &quot;code_commune&quot; select(exercice, 1:7) %&gt;% names() ## [1] &quot;code_analyse&quot; &quot;code_laboratoire&quot; &quot;code_prelevement&quot; ## [4] &quot;code_parametre&quot; &quot;code_fraction_analysee&quot; &quot;resultat_analyse&quot; ## [7] &quot;code_remarque&quot; select(exercice, -c(1:7)) %&gt;% names() ## [1] &quot;limite_detection&quot; &quot;limite_quantification&quot; &quot;code_intervenant&quot; ## [4] &quot;code_reseau&quot; &quot;code_station&quot; &quot;date_prelevement&quot; ## [7] &quot;code_support&quot; &quot;libelle_station&quot; &quot;date_creation&quot; ## [10] &quot;source&quot; &quot;code_masse_eau&quot; &quot;code_entite_hydro&quot; ## [13] &quot;code_troncon_hydro&quot; &quot;code_commune&quot; Sélectionner les variables en fonction de leur position peut sembler séduisant, mais attention aux problèmes de reproductibilité que cela peut poser si le jeu de données en entrée bouge un peu entre deux millésimes. On peut également sélectionner des variables selon des conditions sur leur nom. Par exemple, on peut sélectionner les variables dont le nom commence par “date”, ou se termine par “station”, ou contient “prel” ou en fonction d’une expression régulière comme “m.n” (le nom contient un “m” suivi d’un caractère suivi d’un “n”. select(exercice, starts_with(&quot;date&quot;)) %&gt;% names() ## [1] &quot;date_prelevement&quot; &quot;date_creation&quot; select(exercice, ends_with(&quot;station&quot;)) %&gt;% names() ## [1] &quot;code_station&quot; &quot;libelle_station&quot; select(exercice, contains(&quot;prel&quot;)) %&gt;% names() ## [1] &quot;code_prelevement&quot; &quot;date_prelevement&quot; select(exercice, matches(&quot;m.n&quot;)) %&gt;% names() ## [1] &quot;code_prelevement&quot; &quot;date_prelevement&quot; &quot;code_commune&quot; On peut également sélectionner des variables selon des conditions sur leur type, avec la fonction where(). Par exemple, sélectionner toutes les variables numériques ou toutes les variables de type caractère. select(exercice, where(is.numeric)) %&gt;% names() ## [1] &quot;code_analyse&quot; &quot;code_laboratoire&quot; &quot;code_prelevement&quot; ## [4] &quot;code_parametre&quot; &quot;code_fraction_analysee&quot; &quot;resultat_analyse&quot; ## [7] &quot;code_remarque&quot; &quot;limite_detection&quot; &quot;limite_quantification&quot; ## [10] &quot;code_support&quot; select(exercice, where(is.character)) %&gt;% names() ## [1] &quot;code_station&quot; &quot;date_prelevement&quot; &quot;libelle_station&quot; ## [4] &quot;date_creation&quot; &quot;source&quot; &quot;code_masse_eau&quot; ## [7] &quot;code_entite_hydro&quot; &quot;code_troncon_hydro&quot; &quot;code_commune&quot; On peut enfin sélectionner des variables en combinant les moyens détaillés ci-avant et en recourant aux opérateurs booléens : ! (négation), &amp; (et), | (ou). select(exercice, 1:7 &amp; starts_with(&quot;code&quot;)) %&gt;% names() ## [1] &quot;code_analyse&quot; &quot;code_laboratoire&quot; &quot;code_prelevement&quot; ## [4] &quot;code_parametre&quot; &quot;code_fraction_analysee&quot; &quot;code_remarque&quot; select(exercice, starts_with(&quot;date&quot;) &amp; !where(is.Date)) %&gt;% names() ## [1] &quot;date_prelevement&quot; &quot;date_creation&quot; 5.10.2 Utiliser les select helpers avec les autres verbes du tidyverse 5.10.2.1 rename() et rename_with() Lorsqu’on souhaite renommer les variable une à une, la fonction rename() fonctionne de la même manière que select() : mon_df_renomme &lt;- rename(mon_dataframe, nouveau_nom1 = ancien_nom1, nouveau_nom2 = ancien_nom2) Si l’on souhaite recourir aux select helpers, il faut utiliser rename_with(), avec la syntaxe rename_with(.data= mon_df, .fn= ma_fonction_de_renommage, .cols= les_variables_a_renommer). Exemple avec la fonction toupper() qui passe les chaînes de caractères en majuscules. rename_with(station, toupper, starts_with(&quot;code&quot;)) %&gt;% names() ## [1] &quot;CODE_STATION&quot; &quot;libelle_station&quot; &quot;date_creation&quot; ## [4] &quot;source&quot; &quot;CODE_MASSE_EAU&quot; &quot;CODE_ENTITE_HYDRO&quot; ## [7] &quot;CODE_TRONCON_HYDRO&quot; &quot;CODE_COMMUNE&quot; Si la fonction de renommage est plus complexe qu’un simple mot, il faut recourir au pronom .x et au ~ pour la définir. Exemple avec la fonction str_sub() de {stringr} vue précédemment : rename_with(exercice, ~ str_sub(.x, start = 6, end = str_length(.x)), starts_with(&quot;code&quot;)) %&gt;% names() ## [1] &quot;analyse&quot; &quot;laboratoire&quot; &quot;prelevement&quot; ## [4] &quot;parametre&quot; &quot;fraction_analysee&quot; &quot;resultat_analyse&quot; ## [7] &quot;remarque&quot; &quot;limite_detection&quot; &quot;limite_quantification&quot; ## [10] &quot;intervenant&quot; &quot;reseau&quot; &quot;station&quot; ## [13] &quot;date_prelevement&quot; &quot;support&quot; &quot;libelle_station&quot; ## [16] &quot;date_creation&quot; &quot;source&quot; &quot;masse_eau&quot; ## [19] &quot;entite_hydro&quot; &quot;troncon_hydro&quot; &quot;commune&quot; 5.10.3 filter(), mutate(), group_by(), summarise(), arrange(), transmute()… Les autres verbes de {dplyr} ont besoin de la fonction across() pour fonctionner avec les select helpers. Comme pour rename_with(), les fonctions complexes sont à déclarer avec le ~ et le pronom .x. On peut en désigner plusieurs ou leur fournir un nom qui servira de suffixe aux noms des variables calculées, en passant la ou les fonctions dans une liste : .fn=list(suffixe1 = ma_fonction1, suffixe2 = ma_fonction2). La syntaxe générale devient : monverbe(.data, across(mesvariables, malistedefonctions), across(mesvariables2, malistedefonctions2)) filter(parametre, across(starts_with(&quot;date&quot;), ~ .x &gt; &quot;2015-01-01&quot;)) %&gt;% select(1:7) ## code_parametre nom_parametre statut_parametre ## 1 7782 Desméthyl-chlortoluron Validé ## 2 7801 Cyprosulfamide Validé ## 3 7783 Haloxyfop méthyl Validé ## 4 7748 cyflufénamide Validé ## date_creation_parametre date_maj_parametre auteur_parametre parametre_calcule ## 1 2015-03-10 2015-03-27 INOVALYS Nantes FALSE ## 2 2015-04-30 2015-06-10 AERM FALSE ## 3 2015-03-10 2015-03-27 INOVALYS FALSE ## 4 2015-02-13 2015-02-13 CARSO-LSEHL FALSE mutate(exercice, across(starts_with(&quot;code&quot;) &amp; where(is.numeric), as.factor), across(starts_with(&quot;date&quot;), as.Date)) %&gt;% head() %&gt;% datatable() summarise(parametre, across(starts_with(&quot;code&quot;), n_distinct)) ## code_parametre ## 1 435 group_by(prelevement, across(code_intervenant:code_station)) %&gt;% summarise(across(everything(), list(nb = n_distinct)), .groups = &quot;drop&quot;) ## # A tibble: 766 × 6 ## code_intervenant code_reseau code_station code_prelevement_nb ## &lt;fct&gt; &lt;fct&gt; &lt;chr&gt; &lt;int&gt; ## 1 44 ARS 044000001 51 ## 2 44 ARS 044000044 7 ## 3 44 ARS 044000045 5 ## 4 44 ARS 044000046 4 ## 5 44 ARS 044000047 3 ## 6 44 ARS 044000048 4 ## 7 44 ARS 044000070 6 ## 8 44 ARS 044000071 5 ## 9 44 ARS 044000076 4 ## 10 44 ARS 044000077 5 ## # ℹ 756 more rows ## # ℹ 2 more variables: date_prelevement_nb &lt;int&gt;, code_support_nb &lt;int&gt; Exemple sur l’exercice sur les données sitadel. sitadel &lt;- read_excel(&quot;extdata/ROES_201702.xls&quot;, &quot;AUT_REG&quot;) %&gt;% group_by(REG) %&gt;% mutate(across(where(is.numeric), list(cumul12 = ~ roll_sumr(.x, n = 12))), across(ends_with(&quot;cumul12&quot;), list(evo = ~ 100 * .x / lag (.x, 12) - 100, part = ~ 100 *.x / log_AUT_cumul12))) datatable(sitadel) "],["manipuler-plusieurs-tables.html", "Chapitre 6 Manipuler plusieurs tables 6.1 Concepts généraux 6.2 Principaux exemples de jointure 6.3 Paramétrage du suffixe pour des colonnes présentes dans les deux tables 6.4 Animations de Garrick Abenduie 6.5 Exercice 5", " Chapitre 6 Manipuler plusieurs tables 6.1 Concepts généraux Le package {dplyr} possède également plusieurs fonctions permettant de travailler sur deux tables. On va pouvoir regrouper ces fonctions en plusieurs catégories de manipulations : pour fusionner des informations de deux tables entre elles : jointures transformantes, pour sélectionner des observations d’une table en fonction de celles présentes dans une autre table : jointures filtrantes, pour traiter deux tables ayant les mêmes colonnes et sélectionner sur celles-ci des observations de l’une et l’autre : opérations ensemblistes, des manipulations visant à additionner deux tables ensembles : assemblages. 6.2 Principaux exemples de jointure Dans la capture ci-dessus, les opérations de jointure supposent que la colonne x1 est présente dans a et b. Voici quelques exemples détaillant les principaux cas rencontrés : # jointure avec des noms de colonnes différentes pour la clé # `colonne_c` est une colonne de data_a et `colonne_d` est une colonne de data_b left_join(data_a, data_b, by = c(&quot;colonne_c&quot; = &quot;colonne_d&quot;)) # jointure sur deux colonnes # `colonne_e` et `colonne_f` sont des colonnes de data_a et de data_b left_join(data_a, data_b, by = c(&quot;colonne_e&quot;, &quot;colonne_f&quot;)) # jointure sur deux colonnes avec noms différents # `colonne_g`et `colonne_i` sont des colonnes de data_a, `colonne_h` et `colonne_j` sont des colonnes de data_b left_join(data_a, data_b, by = c(&quot;colonne_g&quot; = &quot;colonne_h&quot;, &quot;colonne_i&quot; = &quot;colonne_j&quot;)) 6.3 Paramétrage du suffixe pour des colonnes présentes dans les deux tables Dans le cas où des colonnes (hors jointure) sont présentes dans data_a et data_b, ces colonnes seront suffixées par : .x pour les colonnes provenant de data_a .y pour les colonnes provenant de data_b Il est possible de modifier ces suffixes en passant le paramètre suffix = c(\"_a\", \"_b\") au moment de la jointure. left_join(data_a, data_b, by = c(&quot;colonne_c&quot; = &quot;colonne_d&quot;), suffix = c(&quot;_a&quot;, &quot;_b&quot;)) 6.4 Animations de Garrick Abenduie Les animations proviennent de : https://www.garrickadenbuie.com/project/tidyexplain/ 6.4.1 Inner join 6.4.2 Left join 6.4.3 Pivot longuer / Pivot wider 6.5 Exercice 5 Dans les données FormationPreparationDesDonnees.RData, chaque analyse est effectuée à partir d’un prélèvement, lui-même réalisé au niveau d’une station. Reconstituer le dataframe exercice qui rassemble les données contenues dans les tables analyse, prelevement et station grâce à des jointures. Il faut partir de la table analyse et faire des jointures calculer le nombre d’analyses réalisées sur des molécules (identifiables par leur code_parametre) et décrites dans le référentiel parametre ; produire une liste des code_parametre associés à des analyses mais absents du référentiel ; produire une table des analyses “orphelines”, c’est-à-dire qui ne correspondent à aucun prélèvement. Résultats attendus : Résultat attendu pour les jointures entre analayse, prelevement et station ## Rows: 153,497 ## Columns: 22 ## $ code_analyse &lt;int&gt; 5186581, 280131, 1576225, 799894, 472800, 27671… ## $ code_laboratoire &lt;dbl&gt; NA, 292, NA, NA, 292, NA, NA, NA, NA, NA, NA, N… ## $ code_prelevement &lt;int&gt; 37593, 7715, 15517, 9566, 8332, 26792, 35625, 1… ## $ code_parametre &lt;dbl&gt; 1216, 1668, 1185, 1217, 1907, 1945, 1673, 1234,… ## $ code_fraction_analysee &lt;int&gt; 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,… ## $ resultat_analyse &lt;dbl&gt; 0.007, 0.050, 0.040, 0.050, 0.260, 0.020, 0.010… ## $ code_remarque &lt;int&gt; 10, 2, 2, 2, 1, 10, 10, 10, 10, 10, 10, 10, 2, … ## $ limite_detection &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… ## $ limite_quantification &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… ## $ code_intervenant &lt;fct&gt; NA, 104, NA, NA, 104, NA, NA, 53, NA, 44, 49, 4… ## $ code_reseau &lt;fct&gt; OSUR, OSUR, FREDON, OSUR, OSUR, OSUR, OSUR, ARS… ## $ code_station &lt;chr&gt; &quot;04153800&quot;, &quot;04130000&quot;, &quot;04132500&quot;, &quot;04214000&quot;,… ## $ date_prelevement &lt;chr&gt; &quot;2014-09-16&quot;, &quot;2003-08-05&quot;, &quot;2008-09-01&quot;, &quot;2007… ## $ code_support &lt;int&gt; NA, 3, NA, NA, 3, NA, NA, 3, NA, 3, 3, 3, NA, N… ## $ libelle_station &lt;chr&gt; &quot;MOZEE à CHANTONNAY&quot;, &quot;MAYENNE à DAON&quot;, &quot;MAYENN… ## $ date_creation &lt;chr&gt; &quot;1900-01-01&quot;, &quot;1900-01-01&quot;, &quot;1900-01-01&quot;, &quot;1900… ## $ source &lt;chr&gt; &quot;AELB&quot;, &quot;AELB&quot;, &quot;AELB&quot;, &quot;AELB&quot;, &quot;AELB&quot;, &quot;AELB&quot;,… ## $ code_masse_eau &lt;chr&gt; &quot;GR1950&quot;, &quot;GR0460c&quot;, &quot;GR0460c&quot;, &quot;GR0121&quot;, &quot;GR04… ## $ code_entite_hydro &lt;chr&gt; &quot;N3036200&quot;, &quot;M---0090&quot;, &quot;M---0090&quot;, &quot;J78-0300&quot;,… ## $ code_troncon_hydro &lt;chr&gt; &quot;N3036200&quot;, &quot;M3620090&quot;, &quot;M3910090&quot;, &quot;J7800300&quot;,… ## $ code_commune &lt;chr&gt; &quot;85051&quot;, &quot;53089&quot;, &quot;49214&quot;, &quot;44036&quot;, &quot;53017&quot;, &quot;5… ## $ annee &lt;dbl&gt; 2014, 2003, 2008, 2007, 2005, 2006, 2013, 2009,… Résultat attendu pour le nombre d’analyses réalisées sur des molécules (code_parametre) présentes dans le référentiel parametre : ## [1] 194382 Résultat attendu pour la liste des code_parametre associés à des analyses mais absents du référentiel : ## [1] 1261 1206 1673 1234 1686 1757 1666 1149 1865 1888 1225 1830 ## [13] 1506 1136 1218 1199 1664 7097 1913 1680 5526 1235 1533 1266 ## [25] 1155 1877 1215 1209 1126 1208 1189 9052 1526 1256 1903 1905 ## [37] 1866 1895 1171 1130 2027 2046 1104 1233 1193 2057 1890 1173 ## [49] 1148 1150 1103 2737 2047 1490 1464 1101 1254 1698 1540 1870 ## [61] 2912 1287 1159 1142 1257 1213 1812 1700 1194 1432 2546 6260 ## [73] 1289 1697 5537 1694 2074 1699 1951 2751 6398 1806 1228 2678 ## [85] 1814 1832 2806 2015 1809 1682 1742 3159 2807 1214 1402 1670 ## [97] 5921 0 1210 1276 1153 2028 1094 1968 6483 1124 1119 1891 ## [109] 1127 1139 1954 1503 1523 1887 1147 1522 1743 1972 1966 1763 ## [121] 2012 2976 1259 1701 1102 1231 1940 1238 2024 5416 1860 5760 ## [133] 1501 1942 6824 1280 1502 2951 1112 1975 1943 1336 1711 1716 ## [145] 1930 1764 1655 1283 1615 1976 1953 7057 2010 1805 2950 2930 ## [157] 1546 2565 5488 1880 1774 1684 1525 1959 1616 1592 1587 2769 ## [169] 2545 2750 2069 5638 2664 1702 1720 1538 1636 2984 5581 2913 ## [181] 6261 6856 1091 1875 7500 1090 1649 1614 1548 7345 2872 2987 ## [193] 1250 12143 2021 1274 1629 1465 2609 3209 1642 2748 1643 2744 ## [205] 1969 1869 7342 1591 1251 1647 2749 1116 2986 2066 1469 1388 ## [217] 2081 1245 2889 5545 1628 1648 2919 1595 1613 1957 1590 1955 ## [229] 1089 2929 2536 1160 3283 1282 1387 1458 7522 1241 3160 2732 ## [241] 1275 1651 1382 1106 1115 12098 1588 1468 1612 2916 1624 1594 ## [253] 12099 1032 1627 2733 1243 2734 1921 1273 2915 6384 1272 1117 ## [265] 1278 1653 1731 1586 1396 2887 1286 2770 5499 1305 1471 1650 ## [277] 1625 1645 1593 2868 1486 1730 1161 7150 2590 2032 1626 1589 ## [289] 1249 1386 1242 2537 1244 1644 1497 1622 2568 1577 1641 Résultat attendu pour la table des analyses “orphelines”, c’est-à-dire ne correspondent à aucun prélèvement : ## Rows: 84,535 ## Columns: 9 ## $ code_analyse &lt;int&gt; 3854590, 1812211, 3124130, 4245401, 3684301, 38… ## $ code_laboratoire &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,… ## $ code_prelevement &lt;int&gt; 32031, 17208, 28512, 33302, 31986, 32146, 17640… ## $ code_parametre &lt;dbl&gt; 2025, 1261, 2045, 2978, 2018, 1190, 1206, 1911,… ## $ code_fraction_analysee &lt;int&gt; 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,… ## $ resultat_analyse &lt;dbl&gt; 2e-02, 5e-02, 1e-02, 1e+01, 1e-02, 2e-02, 2e-02… ## $ code_remarque &lt;int&gt; 10, 10, 10, 10, 133, 10, 10, 10, 10, 10, 10, 10… ## $ limite_detection &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… ## $ limite_quantification &lt;dbl&gt; 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, … "],["structurer-ses-tables.html", "Chapitre 7 Structurer ses tables 7.1 Pourquoi se pencher sur la structuration des tables ? 7.2 Les deux fonctions clefs de {tidyr}", " Chapitre 7 Structurer ses tables 7.1 Pourquoi se pencher sur la structuration des tables ? Pour bien manipuler des données, leur structuration est fondamentale. Il faut bien savoir ce qu’est : une ligne de notre table, une colonne de notre table. Sur une table non agrégée (un répertoire, une table d’enquête…), la structuration naturelle est une ligne par observation (un individu, une entreprise…), une colonne par variable (âge, taille…) sur cette observation. Mais dès qu’on agrège une telle table pour construire des tables structurées par dimensions d’analyse et indicateurs, se pose toujours la question de savoir ce qu’on va considérer comme des dimensions et comme des indicateurs. Le standard tidy data définit 3 principes pour des données propres : chaque variable est une colonne, chaque observation est une ligne, les unités d’observations différentes sont stockées dans des tables différentes. Le respect de ces règles va nous amener parfois à devoir changer la définition des lignes et colonnes de nos tables en entrée. Ci-dessous un exemple simple : la population estimée par département et genre en 2019. Ce fichier est un extrait d’un tableur mis à disposition par l’Insee. estim_pop &lt;- read_excel(&#39;extdata/estim-pop-dep-sexe-gca-2019.xls&#39;) estim_pop ## # A tibble: 104 × 20 ## dep lib_dep Ensemble_019ans Ensemble_2039ans Ensemble_4059ans ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 01 Ain 167720 150949 179476 ## 2 02 Aisne 131435 115046 137405 ## 3 03 Allier 67628 61986 87232 ## 4 04 Alpes-de-Haute-Prove… 33883 30028 43039 ## 5 05 Hautes-Alpes 30518 28633 37887 ## 6 06 Alpes-Maritimes 228072 237427 282270 ## 7 07 Ardèche 71385 62186 88572 ## 8 08 Ardennes 61006 56583 71821 ## 9 09 Ariège 31143 28962 41017 ## 10 10 Aube 74510 69537 78475 ## # ℹ 94 more rows ## # ℹ 15 more variables: Ensemble_6074ans &lt;dbl&gt;, Ensemble_75ansetplus &lt;dbl&gt;, ## # Ensemble_Total &lt;dbl&gt;, Homme_019ans &lt;dbl&gt;, Homme_2039ans &lt;dbl&gt;, ## # Homme_4059ans &lt;dbl&gt;, Homme_6074ans &lt;dbl&gt;, Homme_75ansetplus &lt;dbl&gt;, ## # Homme_Total &lt;dbl&gt;, Femme_019ans &lt;dbl&gt;, Femme_2039ans &lt;dbl&gt;, ## # Femme_4059ans &lt;dbl&gt;, Femme_6074ans &lt;dbl&gt;, Femme_75ansetplus &lt;dbl&gt;, ## # Femme_Total &lt;dbl&gt; En quoi ce fichier n’est pas tidy ? On retrouve 4 variables dans notre fichier : le territoire, le genre, l’âge et la population, et nos colonnes ne correspondent pas à ces variables. Quel serait la version tidy de notre fichier ? ## # A tibble: 1,872 × 5 ## dep lib_dep genre age nombre_individus ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 01 Ain Ensemble 019ans 167720 ## 2 01 Ain Ensemble 2039ans 150949 ## 3 01 Ain Ensemble 4059ans 179476 ## 4 01 Ain Ensemble 6074ans 102788 ## 5 01 Ain Ensemble 75ansetplus 52755 ## 6 01 Ain Ensemble Total 653688 ## 7 01 Ain Homme 019ans 86359 ## 8 01 Ain Homme 2039ans 75242 ## 9 01 Ain Homme 4059ans 89278 ## 10 01 Ain Homme 6074ans 49523 ## # ℹ 1,862 more rows Comment passer facilement d’un format non tidy à un format tidy ? C’est là qu’intervient le package {tidyr}. 7.2 Les deux fonctions clefs de {tidyr} pivot_longer() permet d’empiler plusieurs colonnes (correspondant à des variables quantitatives). Elles sont repérées par création d’une variable qualitative, à partir de leurs noms. Le résultat est une table au format long. pivot_wider() fait l’inverse. Cette fonction crée autant de colonnes qu’il y a de modalités d’une variable qualitative, en remplissant chacune par le contenu d’une variable numérique. Le résultat est une table au format large. Pour avoir un aperçu illustré de ces fonctions, voir cette animation Reprenons notre table Insee d’estimation de population. Comment faire pour passer cette table dans le format tidy ? Première étape, retrouvons notre colonne population. Pour cela, il nous faut passer notre table au format long, grâce à pivot_longer(). estim_pop_tidy &lt;- estim_pop %&gt;% pivot_longer(-c(dep, lib_dep), values_to = &quot;nombre_individus&quot;, names_to = &quot;genre_age&quot;) datatable(estim_pop_tidy) Si nous voulions retrouver le format large, nous pourrions utiliser pivot_wider() estim_pop_nontidy &lt;- estim_pop_tidy %&gt;% pivot_wider(names_from = genre_age, values_from = nombre_individus) datatable(estim_pop_nontidy) Nous n’avons pas encore retrouvé nos deux variables genre et age, mais une seule variable mélange les deux. Pour cela, nous pouvons utiliser separate() du package {tidyr}. estim_pop_tidy &lt;- estim_pop_tidy %&gt;% separate(genre_age, sep = &quot;_&quot;, into = c(&quot;genre&quot;, &quot;age&quot;)) datatable(estim_pop_tidy) Mais pivot_longer() permet d’aller encore plus loin en spécifiant sur nos colonnes un moyen de distinguer nos deux variables directement avec l’argument names_sep. estim_pop_tidy &lt;- estim_pop %&gt;% pivot_longer(-c(dep, lib_dep), names_sep = &quot;_&quot;, names_to = c(&quot;genre&quot;, &quot;age&quot;), values_to = &quot;nombre_individus&quot;) datatable(estim_pop_tidy) Et pivot_wider() permet également d’utiliser deux variables pour définir les modalités à convertir en colonnes. estim_pop_tidy %&gt;% pivot_wider(names_from = c(genre, age), values_from = nombre_individus) %&gt;% datatable() Vous retrouverez une introduction complète à {tidyr} dans un article très bien fait de la documentation du package (en anglais). {tidyr} permet également de transformer des données sous forme de listes en dataframe tidy très simplement. "],["nettoyer-des-données-territoriales-gérer-les-évolutions-du-cog-code-officiel-géographique.html", "Chapitre 8 Nettoyer des données territoriales : gérer les évolutions du COG (code officiel géographique) 8.1 Mettre à jour une table comportant une colonne de code commune 8.2 Mettre à jour le COG et agréger aux différentes échelles 8.3 Sélectionner les territoires de ma zone de travail 8.4 Pour en savoir plus : utiliser les fonds de carte mis à disposition dans COGiter", " Chapitre 8 Nettoyer des données territoriales : gérer les évolutions du COG (code officiel géographique) Lorsque qu’on démarre en analyse de données territoriales, on est parfois surpris de constater que ce qui nous semblent être immuable, comme les contours des régions, départements, communes, ne l’est pas ! Chaque année des communes fusionnent (voire se séparent !), les régions ont bougé avec beaucoup de bruit début 2016, on a même vu récemment une commune changer de département. Bref toute chaîne de traitement de données qui a vocation a être pérennisée doit prendre en compte cette variabilité des contours territoriaux. Le COG ou Code officiel géographique des territoires est administré par l’INSEE, qui publie chaque année la nouvelle liste des communes, départements, regions, et une table de passage annuelle entre anciennes et nouvelles communes. Comme souvent avec R, des utilisateurs soucieux de partager leurs astuces ont conçu des packages pour faciliter les traitement de mise à jour du COG, on peut citer {COGugaison} de Kim Antunez, qui est très précis (conversion d’un millésime à un autre, contrôle des années de conversion, retour en arrière possible) mais seulement adapté pour les tables de données France entière, et le package DREAL Pays de la Loire, initié par Maël Theulière {COGiter}, qui est plus simple (un seul sens : la mise à jour), ce package comprend par ailleurs des services d’agrégation à différentes échelles, de gestion des noms, des contours géo, mais ne gère pas très bien les scission de communes. La mise à jour du COG d’une source avec ces packages n’est possible que si cette dernière est disponible au moins à la maille communale sans secrétisation. Dans ce chapitre sont présentés les usages les plus fréquents de {COGiter}. 8.1 Mettre à jour une table comportant une colonne de code commune Dans nos données relatives aux pesticides, la table des stations comprend le code commune de rattachement de chaque station. {COGiter} permet de tenir à jour cette information d’une fonction : library(COGiter) stations_cog_ok &lt;- passer_au_cog_a_jour(.data = station, code_commune = code_commune, aggrege = FALSE, garder_info_supra = TRUE) Le paramètre “aggrege” sert à indiquer si on souhaite obtenir en sortie une table avec une ligne par commune à jour, en sommant les valeurs numériques de la table. Le paramètre “garder_info_supra” sert à indiquer si on souhaite obtenir en sortie une table comportant en plus les territoires supra-communaux (EPCI, DEP, REG, …) de rattachement. stations_cog_ok %&gt;% names() ## [1] &quot;code_station&quot; &quot;libelle_station&quot; &quot;date_creation&quot; ## [4] &quot;source&quot; &quot;code_masse_eau&quot; &quot;code_entite_hydro&quot; ## [7] &quot;code_troncon_hydro&quot; &quot;DEPCOM&quot; &quot;NOM_DEPCOM&quot; ## [10] &quot;EPCI&quot; &quot;NOM_EPCI&quot; &quot;DEP&quot; ## [13] &quot;NOM_DEP&quot; &quot;REG&quot; &quot;NOM_REG&quot; ## [16] &quot;DEPARTEMENTS_DE_L_EPCI&quot; &quot;REGIONS_DE_L_EPCI&quot; 8.2 Mettre à jour le COG et agréger aux différentes échelles Dans nos données de l’enquête tourisme, l’INSEE nous indique que les communes utilisées pour diffuser les résultats sont de celles 2019. Elles on donc bougé depuis. Imaginions, que nous voudrions avoir les résultats de cette enquête non pas par commune, mais par EPCI et département : la fonction cogifier() nous aide à faire tout ça en un tour de main. glimpse(enq_tourisme) ## Rows: 34,953 ## Columns: 55 ## $ CODGEO &lt;chr&gt; &quot;01001&quot;, &quot;01002&quot;, &quot;01004&quot;, &quot;01005&quot;, &quot;01006&quot;, &quot;01007&quot;, &quot;01008… ## $ LIBGEO &lt;chr&gt; &quot;L&#39;Abergement-Clémenciat&quot;, &quot;L&#39;Abergement-de-Varey&quot;, &quot;Ambérie… ## $ REG &lt;chr&gt; &quot;84&quot;, &quot;84&quot;, &quot;84&quot;, &quot;84&quot;, &quot;84&quot;, &quot;84&quot;, &quot;84&quot;, &quot;84&quot;, &quot;84&quot;, &quot;84&quot;, … ## $ DEP &lt;chr&gt; &quot;01&quot;, &quot;01&quot;, &quot;01&quot;, &quot;01&quot;, &quot;01&quot;, &quot;01&quot;, &quot;01&quot;, &quot;01&quot;, &quot;01&quot;, &quot;01&quot;, … ## $ HT19 &lt;dbl&gt; 0, 0, 1, 2, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, … ## $ HT019 &lt;dbl&gt; 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ HT119 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ HT219 &lt;dbl&gt; 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, … ## $ HT319 &lt;dbl&gt; 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, … ## $ HT419 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ HT519 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ HTCH19 &lt;dbl&gt; 0, 0, 35, 17, 0, 0, 0, 0, 15, 0, 9, 0, 10, 0, 19, 0, 0, 43, … ## $ HTCH019 &lt;dbl&gt; 0, 0, 0, 8, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… ## $ HTCH119 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ HTCH219 &lt;dbl&gt; 0, 0, 35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 43, 23,… ## $ HTCH319 &lt;dbl&gt; 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 19, 0, 0, 0, 0, 0,… ## $ HTCH419 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ HTCH519 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ CPG19 &lt;dbl&gt; 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, … ## $ CPG019 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ CPG119 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ CPG219 &lt;dbl&gt; 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, … ## $ CPG319 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, … ## $ CPG419 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ CPG519 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ CPGE19 &lt;dbl&gt; 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 121, 56,… ## $ CPGE019 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ CPGE119 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ CPGE219 &lt;dbl&gt; 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 121, 0, … ## $ CPGE319 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0,… ## $ CPGE419 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ CPGE519 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ CPGEL19 &lt;dbl&gt; 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0… ## $ CPGEL019 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ CPGEL119 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ CPGEL219 &lt;dbl&gt; 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0… ## $ CPGEL319 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ CPGEL419 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ CPGEL519 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ CPGEO19 &lt;dbl&gt; 0, 0, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 101, 56,… ## $ CPGEO019 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ CPGEO119 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ CPGEO219 &lt;dbl&gt; 0, 0, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 101, 0, … ## $ CPGEO319 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0,… ## $ CPGEO419 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ CPGEO519 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ VV19 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ VVUH19 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ VVLIT19 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ RT19 &lt;dbl&gt; 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ RTUH19 &lt;dbl&gt; 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… ## $ RTLIT19 &lt;dbl&gt; 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… ## $ AJCS19 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ AJCSUH19 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ AJCSLIT19 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … enq_tourisme_epci_dep &lt;- enq_tourisme %&gt;% # on enlève les colonnes textes à mettre à jour select(-LIBGEO, -REG, -DEP) %&gt;% cogifier(code_commune = CODGEO, communes = FALSE, epci = TRUE, departements = TRUE, regions = FALSE, metro = TRUE, franceprovince = FALSE, metrodrom = FALSE, drom = TRUE, na.rm = FALSE) glimpse(enq_tourisme_epci_dep) ## Rows: 1,352 ## Columns: 54 ## $ TypeZone &lt;fct&gt; Epci, Epci, Epci, Epci, Epci, Epci, Epci, Epci, Epci, Epci, … ## $ Zone &lt;fct&gt; &quot;CC Faucigny - Glières&quot;, &quot;CC du Pays de Pontchâteau St-Gilda… ## $ CodeZone &lt;fct&gt; 200000172, 200000438, 200000545, 200000628, 200000800, 20000… ## $ HT19 &lt;dbl&gt; 6, 5, 3, 11, 8, 1, 6, 9, 5, 2, 76, 6, 6, 4, 2, 1, 15, 15, 20… ## $ HT019 &lt;dbl&gt; 2, 2, 0, 2, 4, 1, 3, 2, 0, 1, 14, 4, 4, 0, 1, 1, 7, 5, 5, 2,… ## $ HT119 &lt;dbl&gt; 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 1, 0, 0, 0, … ## $ HT219 &lt;dbl&gt; 4, 1, 2, 6, 2, 0, 2, 2, 1, 0, 14, 0, 1, 2, 1, 0, 1, 10, 3, 0… ## $ HT319 &lt;dbl&gt; 0, 1, 1, 2, 1, 0, 1, 4, 0, 1, 27, 2, 1, 2, 0, 0, 6, 0, 9, 0,… ## $ HT419 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0,… ## $ HT519 &lt;dbl&gt; 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ HTCH19 &lt;dbl&gt; 77, 92, 121, 330, 138, 8, 68, 219, 184, 24, 2414, 102, 89, 1… ## $ HTCH019 &lt;dbl&gt; 16, 29, 0, 60, 46, 8, 21, 17, 0, 6, 250, 50, 47, 0, 7, 10, 1… ## $ HTCH119 &lt;dbl&gt; 0, 0, 0, 61, 17, 0, 0, 0, 7, 0, 84, 0, 0, 0, 0, 0, 59, 0, 0,… ## $ HTCH219 &lt;dbl&gt; 61, 11, 98, 146, 60, 0, 28, 28, 15, 0, 417, 0, 14, 32, 6, 0,… ## $ HTCH319 &lt;dbl&gt; 0, 16, 23, 63, 15, 0, 19, 59, 0, 18, 994, 52, 28, 82, 0, 0, … ## $ HTCH419 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 162, 0, 538, 0, 0, 0, 0, 0, 0, 0, 11… ## $ HTCH519 &lt;dbl&gt; 0, 36, 0, 0, 0, 0, 0, 115, 0, 0, 131, 0, 0, 0, 0, 0, 0, 0, 0… ## $ CPG19 &lt;dbl&gt; 2, 7, 1, 5, 1, 0, 6, 11, 3, 1, 9, 2, 10, 4, 2, 0, 2, 5, 0, 1… ## $ CPG019 &lt;dbl&gt; 1, 3, 0, 1, 0, 0, 3, 2, 1, 1, 2, 1, 2, 3, 0, 0, 0, 3, 0, 0, … ## $ CPG119 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, … ## $ CPG219 &lt;dbl&gt; 1, 1, 0, 0, 0, 0, 2, 2, 2, 0, 1, 1, 3, 0, 1, 0, 0, 0, 0, 0, … ## $ CPG319 &lt;dbl&gt; 0, 2, 0, 2, 1, 0, 0, 5, 0, 0, 5, 0, 5, 1, 1, 0, 2, 0, 0, 1, … ## $ CPG419 &lt;dbl&gt; 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, … ## $ CPG519 &lt;dbl&gt; 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ CPGE19 &lt;dbl&gt; 103, 419, 220, 603, 166, 0, 264, 922, 132, 35, 746, 142, 657… ## $ CPGE019 &lt;dbl&gt; 34, 101, 0, 30, 0, 0, 77, 145, 40, 35, 71, 100, 37, 106, 0, … ## $ CPGE119 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45, 0, 0… ## $ CPGE219 &lt;dbl&gt; 69, 6, 0, 0, 0, 0, 87, 135, 92, 0, 54, 42, 79, 0, 17, 0, 0, … ## $ CPGE319 &lt;dbl&gt; 0, 142, 0, 222, 166, 0, 0, 478, 0, 0, 505, 0, 541, 65, 224, … ## $ CPGE419 &lt;dbl&gt; 0, 170, 220, 276, 0, 0, 100, 110, 0, 0, 116, 0, 0, 0, 0, 0, … ## $ CPGE519 &lt;dbl&gt; 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… ## $ CPGEL19 &lt;dbl&gt; 2, 76, 114, 116, 1, 0, 3, 254, 23, 0, 7, 27, 108, 73, 63, 0,… ## $ CPGEL019 &lt;dbl&gt; 2, 32, 0, 30, 0, 0, 2, 30, 23, 0, 7, 27, 28, 33, 0, 0, 0, 40… ## $ CPGEL119 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… ## $ CPGEL219 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 1, 12, 0, 0, 0, 0, 22, 0, 0, 0, 0, 0, 0, 0… ## $ CPGEL319 &lt;dbl&gt; 0, 18, 0, 8, 1, 0, 0, 158, 0, 0, 0, 0, 58, 40, 63, 0, 32, 0,… ## $ CPGEL419 &lt;dbl&gt; 0, 26, 114, 23, 0, 0, 0, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ CPGEL519 &lt;dbl&gt; 0, 0, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… ## $ CPGEO19 &lt;dbl&gt; 101, 343, 106, 487, 165, 0, 261, 668, 109, 35, 739, 115, 549… ## $ CPGEO019 &lt;dbl&gt; 32, 69, 0, 0, 0, 0, 75, 115, 17, 35, 64, 73, 9, 73, 0, 0, 0,… ## $ CPGEO119 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45, 0, 0… ## $ CPGEO219 &lt;dbl&gt; 69, 6, 0, 0, 0, 0, 86, 123, 92, 0, 54, 42, 57, 0, 17, 0, 0, … ## $ CPGEO319 &lt;dbl&gt; 0, 124, 0, 214, 165, 0, 0, 320, 0, 0, 505, 0, 483, 25, 161, … ## $ CPGEO419 &lt;dbl&gt; 0, 144, 106, 253, 0, 0, 100, 71, 0, 0, 116, 0, 0, 0, 0, 0, 0… ## $ CPGEO519 &lt;dbl&gt; 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… ## $ VV19 &lt;dbl&gt; 0, 1, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ VVUH19 &lt;dbl&gt; 0, 20, 0, 0, 205, 0, 68, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… ## $ VVLIT19 &lt;dbl&gt; 0, 76, 0, 0, 686, 0, 146, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ RT19 &lt;dbl&gt; 0, 0, 0, 0, 1, 0, 0, 6, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, … ## $ RTUH19 &lt;dbl&gt; 0, 0, 0, 0, 746, 0, 0, 440, 0, 0, 70, 0, 0, 0, 0, 0, 0, 0, 3… ## $ RTLIT19 &lt;dbl&gt; 0, 0, 0, 0, 4056, 0, 0, 2233, 0, 0, 360, 0, 0, 0, 0, 0, 0, 0… ## $ AJCS19 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, … ## $ AJCSUH19 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23,… ## $ AJCSLIT19 &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65,… 8.3 Sélectionner les territoires de ma zone de travail Et si je ne souhaite que les territoires de ma région ou de mon département ? # Département du Nord enq_tourisme_epci_dep %&gt;% filtrer_cog(dep = &quot;59&quot;) ## # A tibble: 18 × 54 ## TypeZone Zone CodeZone HT19 HT019 HT119 HT219 HT319 HT419 HT519 HTCH19 ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Epci CA du… 2000306… 2 0 1 0 1 0 0 61 ## 2 Epci CA Co… 2000409… 9 4 0 0 4 1 0 130 ## 3 Epci CC de… 2000409… 3 0 0 0 3 0 0 107 ## 4 Epci CC Pé… 2000419… 2 0 0 0 2 0 0 49 ## 5 Epci CA de… 2000421… 5 1 0 1 2 1 0 204 ## 6 Epci CC Co… 2000432… 2 1 0 0 1 0 0 35 ## 7 Epci CC du… 2000433… 2 2 0 0 0 0 0 29 ## 8 Epci CA Ma… 2000433… 10 2 0 2 6 0 0 420 ## 9 Epci CC du… 2000434… 4 2 0 0 2 0 0 65 ## 10 Epci CA Do… 2000446… 10 2 0 1 6 1 0 527 ## 11 Epci CA de… 2000685… 11 6 0 0 5 0 0 445 ## 12 Epci Métro… 2000932… 113 29 4 15 45 17 3 7407 ## 13 Epci CU de… 2459004… 32 18 2 7 4 1 0 1371 ## 14 Epci CC Fl… 2459007… 1 1 0 0 0 0 0 52 ## 15 Epci CC du… 2459010… 0 0 0 0 0 0 0 0 ## 16 Epci CC Co… 2459011… 0 0 0 0 0 0 0 0 ## 17 Epci CA Va… 2459011… 20 9 0 5 4 2 0 1123 ## 18 Départements Nord 59 226 77 7 31 85 23 3 12025 ## # ℹ 43 more variables: HTCH019 &lt;dbl&gt;, HTCH119 &lt;dbl&gt;, HTCH219 &lt;dbl&gt;, ## # HTCH319 &lt;dbl&gt;, HTCH419 &lt;dbl&gt;, HTCH519 &lt;dbl&gt;, CPG19 &lt;dbl&gt;, CPG019 &lt;dbl&gt;, ## # CPG119 &lt;dbl&gt;, CPG219 &lt;dbl&gt;, CPG319 &lt;dbl&gt;, CPG419 &lt;dbl&gt;, CPG519 &lt;dbl&gt;, ## # CPGE19 &lt;dbl&gt;, CPGE019 &lt;dbl&gt;, CPGE119 &lt;dbl&gt;, CPGE219 &lt;dbl&gt;, CPGE319 &lt;dbl&gt;, ## # CPGE419 &lt;dbl&gt;, CPGE519 &lt;dbl&gt;, CPGEL19 &lt;dbl&gt;, CPGEL019 &lt;dbl&gt;, ## # CPGEL119 &lt;dbl&gt;, CPGEL219 &lt;dbl&gt;, CPGEL319 &lt;dbl&gt;, CPGEL419 &lt;dbl&gt;, ## # CPGEL519 &lt;dbl&gt;, CPGEO19 &lt;dbl&gt;, CPGEO019 &lt;dbl&gt;, CPGEO119 &lt;dbl&gt;, … # Région Bretagne enq_tourisme_epci_dep %&gt;% filtrer_cog(reg = &quot;53&quot;, garder_supra = TRUE) %&gt;% arrange(desc(TypeZone)) ## # A tibble: 1,352 × 54 ## TypeZone Zone CodeZone HT19 HT019 HT119 HT219 HT319 HT419 HT519 HTCH19 ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 France France mé… FRMETRO 17720 4690 405 4363 5957 1936 369 642779 ## 2 France Départeme… DROM 229 102 2 29 64 27 5 11440 ## 3 Epci CC Faucig… 2000001… 6 2 0 4 0 0 0 77 ## 4 Epci CC du Pay… 2000004… 5 2 0 1 1 0 1 92 ## 5 Epci CC des Po… 2000005… 3 0 0 2 1 0 0 121 ## 6 Epci CC Rhône … 2000006… 11 2 1 6 2 0 0 330 ## 7 Epci CC Coeur … 2000008… 8 4 1 2 1 0 0 138 ## 8 Epci CC de la … 2000009… 1 1 0 0 0 0 0 8 ## 9 Epci CC Sauldr… 2000009… 6 3 0 2 1 0 0 68 ## 10 Epci CC du Pay… 2000048… 9 2 0 2 4 0 1 219 ## # ℹ 1,342 more rows ## # ℹ 43 more variables: HTCH019 &lt;dbl&gt;, HTCH119 &lt;dbl&gt;, HTCH219 &lt;dbl&gt;, ## # HTCH319 &lt;dbl&gt;, HTCH419 &lt;dbl&gt;, HTCH519 &lt;dbl&gt;, CPG19 &lt;dbl&gt;, CPG019 &lt;dbl&gt;, ## # CPG119 &lt;dbl&gt;, CPG219 &lt;dbl&gt;, CPG319 &lt;dbl&gt;, CPG419 &lt;dbl&gt;, CPG519 &lt;dbl&gt;, ## # CPGE19 &lt;dbl&gt;, CPGE019 &lt;dbl&gt;, CPGE119 &lt;dbl&gt;, CPGE219 &lt;dbl&gt;, CPGE319 &lt;dbl&gt;, ## # CPGE419 &lt;dbl&gt;, CPGE519 &lt;dbl&gt;, CPGEL19 &lt;dbl&gt;, CPGEL019 &lt;dbl&gt;, ## # CPGEL119 &lt;dbl&gt;, CPGEL219 &lt;dbl&gt;, CPGEL319 &lt;dbl&gt;, CPGEL419 &lt;dbl&gt;, … 8.4 Pour en savoir plus : utiliser les fonds de carte mis à disposition dans COGiter COGiter contient des fonds de cartes des contours administratifs, conçus à partir des couches admin-express de l’IGN et dont la géométrie a été encore simplifiée pour répondre aux besoins de visualisation statistique. Voici un exemple d’usage très sommaire : departements_geo %&gt;% inner_join(enq_tourisme_epci_dep, by = c(&quot;DEP&quot; = &quot;CodeZone&quot;)) %&gt;% select(HT19) %&gt;% plot() Obtenir la liste des fonds de cartes et des fonctionnalités géo : https://maeltheuliere.github.io/COGiter/articles/filtre_geo.html "],["exercice-6-les-données-majic.html", "Chapitre 9 Exercice 6 : les données majic", " Chapitre 9 Exercice 6 : les données majic Calculer à partir des tables fournies dans le fichier majic.RData issues des fichiers fonciers (cf. http://piece-jointe-carto.developpement-durable.gouv.fr/NAT004/DTerNP/html3/_ff_descriptif_tables_image.html#pnb10) un indicateur d’étalement urbain entre 2009 et 2014 à la commune et à l’EPCI sur la région Pays de la Loire (départements 44, 49, 53, 72 et 85), et catégoriser chaque territoire. Définitions : artificialisation = dcnt07 + dcnt09 + dcnt10 + dcnt11 + dcnt12 + dcnt13 indicateur_etalement_simple = évolution de l’artificialisation / évolution de la population indicateur_etalement_avance, indicateur catégoriel qui vaut : 1 si la population progresse ou reste stable alors que l’artificialisation recule ; 2a si la population et l’artificialisation progressent ou sont stables et l’étalement urbain est inférieur ou égal à 1 (ou pop stable) ; 2b si la population et l’artificialisation reculent et l’indicateur d’étalement urbain est supéreur à 1 ; 2c si la population recule et l’indicateur d’étalement est compris entre 0 et 1 (inclus) ; 3 si la population progresse, l’artificialisation progresse plus vite que la population, tout en restant inférieure ou égale à 4,9 m² ; 4 si la population progresse, l’artificialisation est supérieure à 4,9 m², elle progresse plus vite que la population mais au plus 2 fois plus vite ; 5 si la population progresse, l’artificialisation progresse plus de 2 fois plus vite que la population et est supérieure à 4,9 m² ; 6 si la population recule et l’indicateur d’étalement urbain est négatif. Résultats attendus : Résultat attendu : création de l’indicateur artificialisation pour les deux millésimes de majic (solution COGiter) ## Rows: 1,304 ## Columns: 4 ## $ TypeZone &lt;fct&gt; Communes, Communes, Communes, Communes, Communes, Communes,… ## $ Zone &lt;fct&gt; &quot;Abbaretz&quot;, &quot;Aigrefeuille-sur-Maine&quot;, &quot;Ancenis-Saint-Géréon… ## $ CodeZone &lt;fct&gt; 44001, 44002, 44003, 44005, 44006, 44007, 44009, 44010, 440… ## $ artif_2009 &lt;dbl&gt; 3064748, 2408844, 6859785, 6101987, 2379588, 3042688, 50259… ## Rows: 1,304 ## Columns: 4 ## $ TypeZone &lt;fct&gt; Communes, Communes, Communes, Communes, Communes, Communes,… ## $ Zone &lt;fct&gt; &quot;Abbaretz&quot;, &quot;Aigrefeuille-sur-Maine&quot;, &quot;Ancenis-Saint-Géréon… ## $ CodeZone &lt;fct&gt; 44001, 44002, 44003, 44005, 44006, 44007, 44009, 44010, 440… ## $ artif_2014 &lt;dbl&gt; 3160057, 2485622, 7103107, 6496868, 2419875, 3105298, 52452… Résultat attendu : création de les indicateurs pop_2009 et pop_2014 pour les deux millésimes de majic (solution COGiter) ## Rows: 1,304 ## Columns: 4 ## $ TypeZone &lt;fct&gt; Communes, Communes, Communes, Communes, Communes, Communes, C… ## $ Zone &lt;fct&gt; &quot;Abbaretz&quot;, &quot;Aigrefeuille-sur-Maine&quot;, &quot;Ancenis-Saint-Géréon&quot;,… ## $ CodeZone &lt;fct&gt; 44001, 44002, 44003, 44005, 44006, 44007, 44009, 44010, 44012… ## $ pop_2009 &lt;dbl&gt; 1909, 3214, 10639, 5894, 1810, 2465, 8265, 3185, 2595, 2591, … ## Rows: 1,302 ## Columns: 4 ## $ TypeZone &lt;fct&gt; Communes, Communes, Communes, Communes, Communes, Communes, C… ## $ Zone &lt;fct&gt; &quot;Abbaretz&quot;, &quot;Aigrefeuille-sur-Maine&quot;, &quot;Ancenis-Saint-Géréon&quot;,… ## $ CodeZone &lt;fct&gt; 44001, 44002, 44003, 44005, 44006, 44007, 44009, 44010, 44012… ## $ pop_2014 &lt;dbl&gt; 2042, 3714, 10783, 6680, 1830, 2601, 8747, 3086, 2769, 2927, … Résultat attendu : jointude implicite sur idcom et création de l’indicateur d'étalement urbain(solution COGiter) : ## Rows: 1,304 ## Columns: 11 ## $ TypeZone &lt;fct&gt; Communes, Communes, Communes, Communes, Co… ## $ Zone &lt;fct&gt; &quot;Abbaretz&quot;, &quot;Aigrefeuille-sur-Maine&quot;, &quot;Anc… ## $ CodeZone &lt;fct&gt; 44001, 44002, 44003, 44005, 44006, 44007, … ## $ artif_2009 &lt;dbl&gt; 3064748, 2408844, 6859785, 6101987, 237958… ## $ artif_2014 &lt;dbl&gt; 3160057, 2485622, 7103107, 6496868, 241987… ## $ pop_2009 &lt;dbl&gt; 1909, 3214, 10639, 5894, 1810, 2465, 8265,… ## $ pop_2014 &lt;dbl&gt; 2042, 3714, 10783, 6680, 1830, 2601, 8747,… ## $ evoarti &lt;dbl&gt; 3.109847857, 3.187337993, 3.547079099, 6.4… ## $ evopop &lt;dbl&gt; 6.966998, 15.556938, 1.353511, 13.335596, … ## $ ies &lt;dbl&gt; 0.446368388, 0.204882086, 2.620651010, 0.4… ## $ indicateur_etalement_avance &lt;chr&gt; &quot;2a&quot;, &quot;2a&quot;, &quot;3&quot;, &quot;2a&quot;, &quot;3&quot;, &quot;2a&quot;, &quot;2a&quot;, &quot;6… Résultat attendu pour etalement_urbain_commune: ## Rows: 1,232 ## Columns: 11 ## $ TypeZone &lt;fct&gt; Communes, Communes, Communes, Communes, Co… ## $ Zone &lt;fct&gt; &quot;Abbaretz&quot;, &quot;Aigrefeuille-sur-Maine&quot;, &quot;Anc… ## $ CodeZone &lt;fct&gt; 44001, 44002, 44003, 44005, 44006, 44007, … ## $ artif_2009 &lt;dbl&gt; 3064748, 2408844, 6859785, 6101987, 237958… ## $ artif_2014 &lt;dbl&gt; 3160057, 2485622, 7103107, 6496868, 241987… ## $ pop_2009 &lt;dbl&gt; 1909, 3214, 10639, 5894, 1810, 2465, 8265,… ## $ pop_2014 &lt;dbl&gt; 2042, 3714, 10783, 6680, 1830, 2601, 8747,… ## $ evoarti &lt;dbl&gt; 3.109847857, 3.187337993, 3.547079099, 6.4… ## $ evopop &lt;dbl&gt; 6.966998, 15.556938, 1.353511, 13.335596, … ## $ ies &lt;dbl&gt; 0.446368388, 0.204882086, 2.620651010, 0.4… ## $ indicateur_etalement_avance &lt;chr&gt; &quot;2a&quot;, &quot;2a&quot;, &quot;3&quot;, &quot;2a&quot;, &quot;3&quot;, &quot;2a&quot;, &quot;2a&quot;, &quot;6… Résultat attendu pour etalement_urbain_epci: ## Rows: 71 ## Columns: 11 ## $ TypeZone &lt;fct&gt; Epci, Epci, Epci, Epci, Epci, Epci, Epci, … ## $ Zone &lt;fct&gt; &quot;CC du Pays de Pontchâteau St-Gildas-des-B… ## $ CodeZone &lt;fct&gt; 200000438, 200023778, 200033298, 200040475… ## $ artif_2009 &lt;dbl&gt; 27594293, 44299964, 25161639, 24880690, 16… ## $ artif_2014 &lt;dbl&gt; 28629232, 46277932, 26955382, 25836264, 18… ## $ pop_2009 &lt;dbl&gt; 31965, 45278, 27906, 18370, 17608, 29131, … ## $ pop_2014 &lt;dbl&gt; 35112, 48610, 28168, 19004, 17017, 29304, … ## $ evoarti &lt;dbl&gt; 3.750555, 4.464943, 7.128880, 3.840625, 7.… ## $ evopop &lt;dbl&gt; 9.8451431, 7.3589823, 0.9388662, 3.4512793… ## $ ies &lt;dbl&gt; 0.3809548, 0.6067337, 7.5930733, 1.1128120… ## $ indicateur_etalement_avance &lt;chr&gt; &quot;2a&quot;, &quot;2a&quot;, &quot;5&quot;, &quot;3&quot;, &quot;6&quot;, &quot;3&quot;, &quot;5&quot;, &quot;2a&quot;,… Résultat attendu pour le graphique (vu au M5) : "],["aller-plus-loin.html", "Chapitre 10 Aller plus loin", " Chapitre 10 Aller plus loin Quelques références : R for data science : http://r4ds.had.co.nz/transform.html {dplyr}, Introduction : https://dplyr.tidyverse.org/articles/dplyr.html {dplyr}, manipulation de deux tables : https://dplyr.tidyverse.org/articles/two-table.html {tidyr} : https://tidyr.tidyverse.org/ {tidyr}, fonctions pivot : https://tidyr.tidyverse.org/articles/pivot.html Aide mémoire de Rstudio sur {dplyr} et {tidyr} (assez ancien) : https://www.rstudio.com/wp-content/uploads/2016/01/data-wrangling-french.pdf Si vous préférez vous mettre à {data.table} https://s3.amazonaws.com/assets.datacamp.com/img/blog/data+table+cheat+sheet.pdf "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
